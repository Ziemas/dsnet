
#include "dsxdb_prototypes.h"

static const char *help_db[] =
{
  "-Ej",
  "dt [-[abcdefhrqsuvw]*] [<tid>]              スレッドの一覧",
  "ds [-v] [<sid>]                             セマフォの一覧",
  "intr                                        ハンドラの一覧",
  "dq/dd/dw/dh/db/df [<adr> [<cnt>]]           メモリ内容の表示",
  "sq/sd/sw/sh/sb/sf <adr> <val>...            メモリ内容の設定",
  "iq/id/iw/ih/ib [<adr> [<cnt>]]              デバイスからの入力",
  "oq/od/ow/oh/ob <adr> <val>...               デバイスへの出力",
  "bload <fname> <adr>                         バイナリデータのロード",
  "bsave <fname> <adr> <cnt>                   バイナリデータのセーブ",
  "dr [-<cpuid>] [-[hfxw]*] [<reg>]...         レジスタの表示",
  "sr [<reg> <val>]...                         レジスタの設定",
  "rload <fname>                               レジスタのロード",
  "rsave <fname> [<reg>]...                    レジスタのセーブ",
  "pload <fname> [<args>]...                   プログラムのロード",
  "sload [-id <id>] [-b <base>] [<fname>]      シンボルのロード",
  "mload <fname> [<args>]...                   モジュールのロード",
  "mstart [-d] [<fname> [<args>]...]           モジュールの実行",
  "mremove <id>...                             モジュールの削除",
  "mlist [-m] [-i] [-l]                        モジュールの一覧表示",
  "memlist [-s] [-f] [-a <adr>] [-r <range>]   メモリリストの一覧表示",
  "di [-m <mark>] [<adr> [<cnt>]]              逆アセンブル表示",
  "vdi [-<cpuid>] [-m <mark>] [<adr> [<cnt>]]  VU マイクロ命令の逆アセンブル",
  "as <adr> <inst>                             簡易アセンブラ",
  "list [<adr> [<cnt> [<back>]]]               ソース行の表示",
  "bt [<cnt>]                                  バックトレースの表示",
  "bp [<adr>[,<cnt>]]...                       ブレークポイントの設定",
  "ub [all|<adr>]...                           ブレークポイントの削除",
  "be [<adr>]...                               ブレークポイントの有効化",
  "bd [<adr>]...                               ブレークポイントの無効化",
  "hbp [{pc|da|dr|dw}[<uskx><nt>][:<adr>[,<msk>]]]...",
  "                                            ハードウエアブレークポイントの設定",
  "hub [{pc|da|dr|dw}]...                      ハードウエアブレークポイントの削除",
  "run [<fname> [<args>]...]                   プログラムの実行",
  "cont [<cnt>]                                プログラムの継続実行",
  "step [<cnt>]                                プログラムのステップ実行",
  "next [<cnt>]                                プログラムのネクスト実行",
  "lstep [<cnt>]                               ソース行単位でのステップ実行",
  "lnext [<cnt>]                               ソース行単位でのネクスト実行",
  "luntil <line>                               プログラムの指定ソース行までの実行",
  "until <adr>...                              プログラムの指定アドレスまでの実行",
  "break                                       プログラムの中断",
  "wait                                        プログラムの停止を待つ",
  "reset [-i | <ebootp> [<ibootp>]]            ターゲットのリセット",
  "xgkt <fname> <cnt> [<off>]                  XGKICK のトレース開始",
  "dbgctl {vu0|vu1} {on|off}                   デバッグモードの設定",
  "storeimage <fname> <bp> <bw> <psm> <x> <y> <w> <h>",
  "                                            GS イメージデータの保存",
  "bpfunc <adr>                                ブレークポイント関数の設定",
  "set [all] [<var>[=<val>]]                   オプションの表示/設定",
  "alias [-r] [<name> [<value>]]               別名の表示/設定",
  "subst [-r] [<pattern> <replace>...]         入力行置換の表示/設定",
  "source <fname>                              ファイルからのコマンド実行",
  "! [<cmd> [<args>]...]]                      シェル呼び出し",
  "cd [<dir>]                                  カレントディレクトリの変更",
  "printf \"<fmt>\" [<args>]...                  書式付きメッセージ出力",
  "record [[-a] <fname>]                       画面出力内容の記録開始/終了",
  "if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                            条件付きコマンド実行",
  "repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                            コマンドの繰り返し実行",
  "show [log|status|history|dbconf|symbol|mdebug]...",
  "                                            内部情報の表示",
  "quit                                        dsedb の終了",
  "help [<keyword>]...                         ヘルプ表示",
  "-Ee",
  "dt [-[abcdefhrqsuvw]*] [<tid>]              display thread",
  "ds [-v] [<sid>]                             display semaphore",
  "intr                                        display handler",
  "dq/dd/dw/dh/db/df [<adr> [<cnt>]]           display memory",
  "sq/sd/sw/sh/sb/sf <adr> <val>...            store memory",
  "iq/id/iw/ih/ib [<adr> [<cnt>]]              input from device",
  "oq/od/ow/oh/ob <adr> <val>...               output to device",
  "bload <fname> <adr>                         binary load",
  "bsave <fname> <adr> <cnt>                   binary save",
  "dr [-<cpuid>] [-[hfxw]*] [<reg>]...         display register(s)",
  "sr [<reg> <val>]...                         set register(s)",
  "rload <fname>                               load register(s)",
  "rsave <fname> [<reg>]...                    store register(s)",
  "pload <fname> [<args>]...                   program load",
  "sload [-id <id>] [-b <base>] [<fname>]      symbol load",
  "mload <fname> [<args>]...                   module load",
  "mstart [-d] [<fname> [<args>]...]           module start",
  "mremove <id>...                             module remove",
  "mlist [-m] [-i] [-l]                        module list",
  "memlist [-s] [-f] [-a <adr>] [-r <range>]   memory block list",
  "di [-m <mark>] [<adr> [<cnt>]]              disassemble",
  "vdi [-<cpuid>] [-m <mark>] [<adr> [<cnt>]]  VU disassemble",
  "as <adr> <inst>                             assemble",
  "list [<adr> [<cnt> [<back>]]]               list source line",
  "bt [<cnt>]                                  backtrace",
  "bp [<adr>[,<cnt>]]...                       set breakpoint",
  "ub [all|<adr>]...                           remove breakpoint",
  "be [<adr>]...                               enable breakpoint",
  "bd [<adr>]...                               disable breakpoint",
  "hbp [{pc|da|dr|dw}[<uskx><nt>][:<adr>[,<msk>]]]... ",
  "                                            set hardware breakpoint",
  "hub [{pc|da|dr|dw}]...                      remove hardware breakpoint",
  "run [<fname> [<args>]...]                   run program",
  "cont [<cnt>]                                continue program",
  "step [<cnt>]                                step instruction",
  "next [<cnt>]                                next instruction",
  "lstep [<cnt>]                               step source line",
  "lnext [<cnt>]                               next source line",
  "luntil <line>                               continue to the specified source line with temp-bp",
  "until <adr>...                              continue to the specified address with temp-bp",
  "break                                       break program",
  "wait                                        wait program",
  "reset [-i | <ebootp> [<ibootp>]]            reset target",
  "xgkt <fname> <cnt> [<off>]                  start XGKICK trace",
  "dbgctl {vu0|vu1} {on|off}                   debug control",
  "storeimage <fname> <bp> <bw> <psm> <x> <y> <w> <h>",
  "                                            store GS image",
  "bpfunc <adr>                                set break point function",
  "set [all] [<var>[=<val>]]                   show/set options",
  "alias [-r] [<name> [<value>]]               show/set alias",
  "subst [-r] [<pattern> <replace>...]         show/set substitution",
  "source <fname>                              read and execute commands",
  "! [<cmd> [<args>]...]]                      invoke shell",
  "cd [<dir>]                                  change directory",
  "printf \"<fmt>\" [<args>]...                  format and print",
  "record [[-a] <fname>]                       start/stop recording",
  "if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                            conditional execution",
  "repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                            repeat commands",
  "show [log|status|history|dbconf|symbol|mdebug]...",
  "                                            show information",
  "quit                                        quit",
  "help [<keyword>]...                         print help",
  "-Ij",
  "dq/dd/dw/dh/db/df [<adr> [<cnt>]]           メモリ内容の表示",
  "sq/sd/sw/sh/sb/sf <adr> <val>...            メモリ内容の設定",
  "iq/id/iw/ih/ib [<adr> [<cnt>]]              デバイスからの入力",
  "oq/od/ow/oh/ob <adr> <val>...               デバイスへの出力",
  "bload <fname> <adr>                         バイナリデータのロード",
  "bsave <fname> <adr> <cnt>                   バイナリデータのセーブ",
  "dr [<reg>]...                               レジスタの表示",
  "sr [<reg> <val>]...                         レジスタの設定",
  "rload <fname>                               レジスタのロード",
  "rsave <fname> [<reg>]...                    レジスタのセーブ",
  "mload <fname> [<args>]...                   モジュールのロード",
  "mstart [-d] [<fname> [<args>]...]           モジュールの実行",
  "mremove <id>...                             モジュールの削除",
  "mlist [-m] [-i] [-l]                        モジュールの一覧表示",
  "memlist [-s] [-f] [-a <adr>] [-r <range>]   メモリリストの一覧表示",
  "sload [-id <id>] [-b <base>] [<fname>]      シンボルのロード",
  "di [-m <mark>] [<adr> [<cnt>]]              逆アセンブル表示",
  "as <adr> <inst>                             簡易アセンブラ",
  "list [<adr> [<cnt> [<back>]]]               ソース行の表示",
  "bt [<cnt>]                                  バックトレースの表示",
  "bp [<adr>[,<cnt>]]...                       ブレークポイントの設定",
  "ub [all|<adr>]...                           ブレークポイントの削除",
  "be [<adr>]...                               ブレークポイントの有効化",
  "bd [<adr>]...                               ブレークポイントの無効化",
  "hbp [{pc|da|dr|dw}[<ku>][:<adr>[,<msk>]]]...",
  "                                            ハードウエアブレークポイントの設定",
  "hub [{pc|da|dr|dw}]...                      ハードウエアブレークポイントの削除",
  "cont [<cnt>]                                プログラムの継続実行",
  "step [<cnt>]                                プログラムのステップ実行",
  "next [<cnt>]                                プログラムのネクスト実行",
  "lstep [<cnt>]                               ソース行単位でのステップ実行",
  "lnext [<cnt>]                               ソース行単位でのネクスト実行",
  "luntil <line>                               プログラムの指定ソース行までの実行",
  "until <adr>...                              プログラムの指定アドレスまでの実行",
  "break                                       プログラムの中断",
  "wait                                        プログラムの停止を待つ",
  "reset [-i | <ebootp> [<ibootp>]]            ターゲットのリセット",
  "bpfunc <adr>                                ブレークポイント関数の設定",
  "set [all] [<var>[=<val>]]                   オプションの表示/設定",
  "alias [-r] [<name> [<value>]]               別名の表示/設定",
  "subst [-r] [<pattern> <replace>...]         入力行置換の表示/設定",
  "source <fname>                              ファイルからのコマンド実行",
  "! [<cmd> [<args>]...]]                      シェル呼び出し",
  "cd [<dir>]                                  カレントディレクトリの変更",
  "printf \"<fmt>\" [<args>]...                  書式付きメッセージ出力",
  "record [[-a] <fname>]                       画面出力内容の記録開始/終了",
  "if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                            条件付きコマンド実行",
  "repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                            コマンドの繰り返し実行",
  "show [log|status|history|dbconf|symbol|mdebug]...",
  "                                            内部情報の表示",
  "quit                                        dsidb の終了",
  "help [<keyword>]...                         ヘルプ表示",
  "-Ie",
  "dq/dd/dw/dh/db/df [<adr> [<cnt>]]           display memory",
  "sq/sd/sw/sh/sb/sf <adr> <val>...            store memory",
  "iq/id/iw/ih/ib [<adr> [<cnt>]]              input from device",
  "oq/od/ow/oh/ob <adr> <val>...               output to device",
  "bload <fname> <adr>                         binary load",
  "bsave <fname> <adr> <cnt>                   binary save",
  "dr [<reg>]...                               display register(s)",
  "sr [<reg> <val>]...                         set register(s)",
  "rload <fname>                               load register(s)",
  "rsave <fname> [<reg>]...                    store register(s)",
  "mload <fname> [<args>]...                   module load",
  "mstart [-d] [<fname> [<args>]...]           module start",
  "mremove <id>...                             module remove",
  "mlist [-m] [-i] [-l]                        module list",
  "memlist [-s] [-f] [-a <adr>] [-r <range>]   memory block list",
  "sload [-id <id>] [-b <base>] [<fname>]      symbol load",
  "di [-m <mark>] [<adr> [<cnt>]]              disassemble",
  "as <adr> <inst>                             assemble",
  "list [<adr> [<cnt> [<back>]]]               list source line",
  "bt [<cnt>]                                  backtrace",
  "bp [<adr>[,<cnt>]]...                       set breakpoint",
  "ub [all|<adr>]...                           remove breakpoint",
  "be [<adr>]...                               enable breakpoint",
  "bd [<adr>]...                               disable breakpoint",
  "hbp [{pc|da|dr|dw}[<ku>][:<adr>[,<msk>]]]...",
  "                                            set hardware breakpoint",
  "hub [{pc|da|dr|dw}]...                      remove hardware breakpoint",
  "cont [<cnt>]                                continue program",
  "step [<cnt>]                                step instruction",
  "next [<cnt>]                                next instruction",
  "lstep [<cnt>]                               step source line",
  "lnext [<cnt>]                               next source line",
  "luntil <line>                               continue to the specified source line with temp-bp",
  "until <adr>...                              continue to the specified address with temp-bp",
  "break                                       break program",
  "wait                                        wait program",
  "reset [-i | <ebootp> [<ibootp>]]            reset target",
  "bpfunc <adr>                                set break point function",
  "set [all] [<var>[=<val>]]                   show/set options",
  "alias [-r] [<name> [<value>]]               show/set alias",
  "subst [-r] [<pattern> <replace>...]         show/set substitution",
  "source <fname>                              read and execute commands",
  "! [<cmd> [<args>]...]]                      invoke shell",
  "cd [<dir>]                                  change directory",
  "printf \"<fmt>\" [<args>]...                  format and print",
  "record [[-a] <fname>]                       start/stop recording",
  "if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                            conditional execution",
  "repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                            repeat commands",
  "show [log|status|history|dbconf|symbol|mdebug]...",
  "                                            show information",
  "quit                                        quit",
  "help [<keyword>]...                         print help",
  "-L0",
  "-Ej command",
  " thread       スレッド、セマフォ、割り込みハンドラの表示",
  " memory       メモリの表示/設定、バイナリロード/セーブ",
  " device       デバイスの入出力",
  " register     レジスタの表示/設定、レジスタロード/セーブ",
  " module       モジュールのロード、開始、リスト表示 instruction  逆アセンブル、アセンブル",
  " execution    ブレークポイントの設定/削除、および実行",
  " other        リセット、オプション制御など",
  "-Ee command",
  " thread       display thread, semaphore, interrupt handler",
  " memory       display/store memory, binary load/save",
  " device       device input/output",
  " register     display/store register, register load/save",
  " module       load/start/list module",
  " instruction  disassemble, assemble",
  " execution    set/delete breakpoint, execution",
  " other        reset, option control, ...etc",
  "-Ij command",
  " memory       メモリの表示/設定、バイナリロード/セーブ",
  " device       デバイスの入出力",
  " register     レジスタの表示/設定、レジスタロード/セーブ",
  " module       モジュールのロード、開始、リスト表示 instruction  逆アセンブル、アセンブル",
  " execution    ブレークポイントの設定/削除、および実行",
  " other        リセット、オプション制御など",
  "-Ie command",
  " memory       display/store memory, binary load/save",
  " device       device input/output",
  " register     display/store register, register load/save",
  " module       load/start/list module",
  " instruction  disassemble, assemble",
  " execution    set/delete breakpoint, execution",
  " other        reset, option control, ...etc",
  "-L1",
  "-Ej thread",
  " dt [-[abcdefhrqsuvw]*] [<tid>]   # スレッドの一覧",
  " ds [-v] [<sid>]                 # セマフォの一覧",
  " intr                            # ハンドラの一覧",
  "-Ee thread",
  " dt [-[abcdefhrqsuvw]*] [<tid>]   # display thread",
  " ds [-v] [<sid>]                 # display semaphore",
  " intr                            # display handler",
  "-L2",
  "-Ej dt dt [-[abcdefhrqsuvw]*] [<tid>]   # スレッドの一覧",
  "",
  " no arguments スレッド一覧を表示します。",
  " -v           コンテキストの詳細を表示します。",
  " -b           スレッドのバックトレースを表示します。",
  "              bt コマンドの疑似変数 $BT<n>,$SFA<n>,$SFS<n> は、",
  "              最後に表示されたバックトレースで設定されます。",
  " -a           すべてのスレッドの一覧を表示します。",
  " -e           RUN 状態のスレッド一覧を表示します。",
  " -r           READY 状態のスレッド一覧を表示します。",
  " -w           WAIT 状態のスレッド一覧を表示します。",
  " -s           SUSPEND 状態のスレッド一覧を表示します。",
  " -u           WAIT-SUSPEND 状態のスレッド一覧を表示します。",
  " -d           DORMANT 状態のスレッド一覧を表示します。",
  " -q           スレッドレディーキュー一覧を表示します。",
  "",
  " -h           詳細を表示するとき浮動小数点レジスタを 16 進表記します。",
  " -f           詳細を表示するとき浮動小数点レジスタを浮動小数表記します。",
  "              [default]",
  "",
  " -c           スレッドが RUN 状態になった回数 count を0に初期化します。",
  "",
  " [<tid>]      <tid> で指定されたスレッドID のコンテキストの詳細を表示します。",
  "",
  " 項目         内容",
  " tid          スレッドID",
  " prio         現在の優先度",
  " pc           プログラムカウンタ",
  " sp           スタックポインタ",
  " status       スレッドの状態",
  " cause        WAIT 要因",
  " count        スレッドが RUN 状態になった回数",
  " func         スレッドの開始アドレスとそのシンボル",
  " args         引数",
  " argc         引数の数",
  " end of heap  ヒープの終端アドレス",
  " stack        スタックのボトムアドレス",
  " stackpointer ユーザーのスタックのトップアドレス(= $sp - 0x280)",
  " stacksize    スタックサイズ",
  "",
  " k0($26)とk1($27)の値は、コンテキストに保存されていません。",
  "-Ee dt",
  " dt [-[abcdefhrqsuvw]*] [<tid>]   # display thread",
  "",
  " no arguments Display table of thread",
  " -v           Display detail of thread",
  " -b           Display backtrace of thread",
  "              The pseudo variables $BT<n>,$SFA<n>,$SFS<n> in bt command",
  "              are set by last display of backtrace.",
  " -a           Display all thread",
  " -e           Display thread of RUN status",
  " -r           Display thread of READY status",
  " -w           Display thread of WAIT status",
  " -s           Display thread of SUSPEND status",
  " -u           Display thread of WAIT-SUSPEND status",
  " -d           Display thread of DORMANT status",
  " -q           Display thread ready queue on order",
  " -h           Display 32-bit value in hex. (fpr,facc) ",
  " -f           Display 32-bit value in floating-point number. (fpr,facc)",
  "              [default]",
  "",
  " -c           Initialize thread count",
  "",
  " <tid>        Display the detail of thread from the specified",
  "              thread id <tid>.",
  "",
  " Item         Descripttion",
  " tid          thread id",
  " prio         current priority",
  " pc           program counter",
  " sp           stack pointer",
  " status       status of thread",
  " cause        cause of WAIT status",
  " count        count of entring RUN status",
  " func         entry address of thread and symbol",
  " args         arguments",
  " argc         the number of arguments",
  " end of heap  address of end of heap",
  " stack        address of stack",
  " stackpointer address of user stackpointer(= $sp - 0x280)",
  " stacksize    size of stack",
  "",
  " k0($26) and k1($27) are not saved in context.",
  "-Ee ds",
  " ds [-v] [<sid>]                 # Display semaphore",
  "",
  " no arguments Display all semaphore",
  " <sid>        Display the detail of semaphore from the specified",
  "              semaphore id <sid>.",
  " -v           Display detail of the semaphore",
  "",
  " Item         Description",
  " sid          semaphre id",
  " count        count of semaphore resource",
  " maxcount     max count of semaphore resource",
  " attr         attribute of semaphore",
  " option       option parameter",
  " numwait      the number of thread waiting for semaphore",
  " tid          Waiting thread ID for semaphore",
  "              Display thread IDs in the order of which comes",
  "              to WAIT state",
  "-Ee intr",
  " intr                            # Display interrupt handler ",
  "",
  " Display an interrupt handler that is registered in EE kernel",
  " by cause of individual interrupts in the order of call.",
  "",
  " Item         Description",
  " INTC         INTC interruption",
  " DMAC         DMAC interruption",
  " ON           interrupt enable",
  " OFF          interrupt disable",
  " func         entry of interrupt handler function",
  " arg          argument of interrupt handler function",
  "-Ej ds",
  " ds [-v] [<sid>]                 # セマフォの一覧",
  "",
  " 引数なし    全てのセマフォを表示します。",
  " <sid>       <sid>で指定されたセマフォIDの詳細を表示します。",
  " -v          セマフォの詳細を表示します。",
  " 項目        内容 sid         セマフォID",
  " count       セマフォ資源数",
  " maxcount    セマフォ資源数の最大値",
  " attr        セマフォの属性",
  " option      ユーザ定義の付化情報",
  " numwait     セマフォ待ちのスレッド数",
  " tid         セマフォ待ちのスレッドID",
  "             スレッドIDは、WAIT状態になった順番で表示されます。",
  "-Ej intr",
  " intr                            # 割り込みハンドラの一覧",
  "",
  " EEカーネルに登録された割り込みハンドラを割り込み要因ごとに",
  " 呼び出される順で表示します。",
  "",
  " 項目        内容",
  " INTC        INTC割り込み",
  " DMAC        DMAC割り込み",
  " ON          割り込みが有効",
  " OFF         割り込みが無効",
  " func        登録された割り込みハンドラ関数 arg         割り込みハンドラへの引数",
  "-L1",
  "--j memory",
  " dq [<adr> [<cnt>]]              # メモリ内容の表示 (quad)",
  " dd [<adr> [<cnt>]]              # メモリ内容の表示 (double)",
  " dw [<adr> [<cnt>]]              # メモリ内容の表示 (word)",
  " dh [<adr> [<cnt>]]              # メモリ内容の表示 (half)",
  " db [<adr> [<cnt>]]              # メモリ内容の表示 (byte)",
  " df [<adr> [<cnt>]]              # メモリ内容の表示 (float)",
  " sq <adr> <val>...               # メモリ内容の設定 (quad)",
  " sd <adr> <val>...               # メモリ内容の設定 (double)",
  " sw <adr> <val>...               # メモリ内容の設定 (word)",
  " sh <adr> <val>...               # メモリ内容の設定 (half)",
  " sb <adr> <val>...               # メモリ内容の設定 (byte)",
  " sf <adr> <fval>...              # メモリ内容の設定 (float)",
  " bload <fname> <adr>             # バイナリデータのロード",
  " bsave <fname> <adr> <cnt>       # バイナリデータのセーブ",
  "--e memory",
  " dq [<adr> [<cnt>]]              # Display of memory contents (quad)",
  " dd [<adr> [<cnt>]]              # Display of memory contents (double)",
  " dw [<adr> [<cnt>]]              # Display of memory contents (word)",
  " dh [<adr> [<cnt>]]              # Display of memory contents (half)",
  " db [<adr> [<cnt>]]              # Display of memory contents (byte)",
  " df [<adr> [<cnt>]]              # Display of memory contents (float)",
  " sq <adr> <val>...               # Setting of memory contents (quad)",
  " sd <adr> <val>...               # Setting of memory contents (double)",
  " sw <adr> <val>...               # Setting of memory contents (word)",
  " sh <adr> <val>...               # Setting of memory contents (half)",
  " sb <adr> <val>...               # Setting of memory contents (byte)",
  " sf <adr> <fval>...              # Setting of memory contents (float)",
  " bload <fname> <adr>             # Binary data load",
  " bsave <fname> <adr> <cnt>       # Binary data save",
  "-L2",
  "--j dq dd dw dh db df",
  "  dq [<adr> [<cnt>]]              # メモリ内容の表示 (quad)",
  "  dd [<adr> [<cnt>]]              # メモリ内容の表示 (double)",
  "  dw [<adr> [<cnt>]]              # メモリ内容の表示 (word)",
  "  dh [<adr> [<cnt>]]              # メモリ内容の表示 (half)",
  "  db [<adr> [<cnt>]]              # メモリ内容の表示 (byte)",
  "  df [<adr> [<cnt>]]              # メモリ内容の表示 (float)",
  "",
  "    指定アドレス <adr> からメモリの内容を表示します。",
  "    <adr> のデフォルトはドットアドレス(現在のアドレス)です。",
  "    <cnt> は一度に表示するバイト数で、dq などで端数がある場合には切り上げ",
  "    られます。128bit 単位でアクセスしなければならない I/O レジスタなどに",
  "    対して、dq 以外のコマンド等でアクセスした場合の値は保証できません。",
  "--e dq dd dw dh db df",
  "  dq [<adr> [<cnt>]]              # Display of memory contents (quad)",
  "  dd [<adr> [<cnt>]]              # Display of memory contents (double)",
  "  dw [<adr> [<cnt>]]              # Display of memory contents (word)",
  "  dh [<adr> [<cnt>]]              # Display of memory contents (half)",
  "  db [<adr> [<cnt>]]              # Display of memory contents (byte)",
  "  df [<adr> [<cnt>]]              # Display of memory contents (float)",
  "",
  "    The debugger displays the contents of the memory from the specified ",
  "    address <adr>.  ",
  "    The default of <adr> is a dot address (current address). ",
  "    <cnt> is the number of bytes displayed at a time, and is rounded up ",
  "    when there is a fraction with the dq etc.  For the I/O register etc., ",
  "    which should be accessed in 128-bit units, the value obtained when ",
  "    getting access with a command other than the dq cannot be guaranteed. ",
  "--j sq sd sw sh sb sf",
  "  sq <adr> <val>...               # メモリ内容の設定 (quad)",
  "  sd <adr> <val>...               # メモリ内容の設定 (double)",
  "  sw <adr> <val>...               # メモリ内容の設定 (word)",
  "  sh <adr> <val>...               # メモリ内容の設定 (half)",
  "  sb <adr> <val>...               # メモリ内容の設定 (byte)",
  "  sf <adr> <fval>...              # メモリ内容の設定 (float)",
  "",
  "    指定アドレス <adr> 以降のメモリに指定データ <val>... を設定します。",
  "",
  "    sf コマンドの指定データ <fval> は浮動小数を含む表現式で、",
  "    以下の表現式のみが指定可能です。",
  "",
  "      <floating_point_number>",
  "      (<fexpr>)",
  "      +<fexpr>",
  "      -<fexpr>",
  "      *<fexpr>",
  "      <fexpr1> + <fexpr2>",
  "      <fexpr1> - <fexpr2>",
  "      <fexpr1> * <fexpr2>",
  "      <fexpr1> / <fexpr2>",
  "--e sq sd sw sh sb sf",
  "  sq <adr> <val>...               # Setting of memory contents  (quad)",
  "  sd <adr> <val>...               # Setting of memory contents  (double)",
  "  sw <adr> <val>...               # Setting of memory contents  (word)",
  "  sh <adr> <val>...               # Setting of memory contents  (half)",
  "  sb <adr> <val>...               # Setting of memory contents  (byte)",
  "  sf <adr> <fval>...              # Setting of memory contents  (float)",
  "",
  "    The debugger sets the specified data <val>... to the memory after ",
  "    the specified address <adr>.",
  "",
  "    The specified data <fval>... of sf command is floating-expression which",
  "    is defined by the follows.",
  "",
  "      <floating_point_number>",
  "      (<fexpr>)",
  "      +<fexpr>",
  "      -<fexpr>",
  "      *<fexpr>",
  "      <fexpr1> + <fexpr2>",
  "      <fexpr1> - <fexpr2>",
  "      <fexpr1> * <fexpr2>",
  "      <fexpr1> / <fexpr2>",
  "--j bload",
  "  bload <fname> <adr>             # バイナリデータのロード",
  "",
  "    ファイル <fname> のすべての内容をバイナリデータとして、",
  "    開始アドレス <adr> で指定された領域にロードします。",
  "--e bload",
  "  bload <fname> <adr>             # Binary data load",
  "",
  "    This command loads all the contents of the file <fname> to the area ",
  "    specified by the start address <adr> as binary data.",
  "--j bsave",
  "  bsave <fname> <adr> <cnt>       # バイナリデータのセーブ",
  "",
  "    ファイル <fname> に、アドレス <adr> からバイト数 <cnt> の領域の内容を",
  "    バイナリデータとしてセーブします。",
  "--e bsave",
  "  bsave <fname> <adr> <cnt>       # Binary data save",
  "",
  "    This command saves the contents of the area from the address <adr> ",
  "    to the byte number <cnt> in the file <frame> as binary data.",
  "-L1",
  "--j device",
  " iq [<adr> [<cnt>]]              # デバイスからの入力 (quad)",
  " id [<adr> [<cnt>]]              # デバイスからの入力 (double)",
  " iw [<adr> [<cnt>]]              # デバイスからの入力 (word)",
  " ih [<adr> [<cnt>]]              # デバイスからの入力 (half)",
  " ib [<adr> [<cnt>]]              # デバイスからの入力 (byte)",
  " oq <adr> <val>...               # デバイスへの出力 (quad)",
  " od <adr> <val>...               # デバイスへの出力 (double)",
  " ow <adr> <val>...               # デバイスへの出力 (word)",
  " oh <adr> <val>...               # デバイスへの出力 (half)",
  " ob <adr> <val>...               # デバイスへの出力 (byte)",
  "--e device",
  " iq [<adr> [<cnt>]]              # Input from device (quad)",
  " id [<adr> [<cnt>]]              # Input from device (double)",
  " iw [<adr> [<cnt>]]              # Input from device (word)",
  " ih [<adr> [<cnt>]]              # Input from device (half)",
  " ib [<adr> [<cnt>]]              # Input from device (byte)",
  " oq <adr> <val>...               # Output to device (quad)",
  " od <adr> <val>...               # Output to device (double)",
  " ow <adr> <val>...               # Output to device (word)",
  " oh <adr> <val>...               # Output to device (half)",
  " ob <adr> <val>...               # Output to device (byte)",
  "-L2",
  "--j iq id iw ih ib",
  "  iq [<adr> [<cnt>]]              # デバイスからの入力 (quad)",
  "  id [<adr> [<cnt>]]              # デバイスからの入力 (double)",
  "  iw [<adr> [<cnt>]]              # デバイスからの入力 (word)",
  "  ih [<adr> [<cnt>]]              # デバイスからの入力 (half)",
  "  ib [<adr> [<cnt>]]              # デバイスからの入力 (byte)",
  "",
  "    指定アドレス <adr> のデバイスからデータを入力し、結果を表示します。",
  "    <adr> のデフォルトアドレスは前回の指定アドレスです。",
  "    <cnt> はデータ数で、アドレスとともに省略した場合には前回の指定数となり、",
  "    アドレスを指定した場合には 1 となります。",
  "    dq/dd/dw/dh/db と異なりドットアドレスの更新は行いません。",
  "--e iq id iw ih ib",
  "  iq [<adr> [<cnt>]]              # Input from device (quad)",
  "  id [<adr> [<cnt>]]              # Input from device (double)",
  "  iw [<adr> [<cnt>]]              # Input from device (word)",
  "  ih [<adr> [<cnt>]]              # Input from device (half)",
  "  ib [<adr> [<cnt>]]              # Input from device (byte)",
  "",
  "    The debugger inputs data from the device in the specified ",
  "    address <adr> and displays the results.",
  "    The default address of <adr> is the last-specified address.",
  "    <cnt> is the number of data.  It becomes the last-specified ",
  "    number when omitted together with the address.  It becomes ",
  "    1 when the address is specified. ",
  "    Unlike dq/dd/dw/dh/db, the dot address is not updated.",
  "--j oq od ow oh ob",
  "  oq <adr> <val>...               # デバイスへの出力 (quad)",
  "  od <adr> <val>...               # デバイスへの出力 (double)",
  "  ow <adr> <val>...               # デバイスへの出力 (word)",
  "  oh <adr> <val>...               # デバイスへの出力 (half)",
  "  ob <adr> <val>...               # デバイスへの出力 (byte)",
  "",
  "    指定アドレス <adr> 以降のデバイスに指定データ <val>... を出力します。",
  "    sq/sd/sw/sh/sb と異なりドットアドレスの更新は行いません。",
  "--e oq od ow oh ob",
  "  oq <adr> <val>...               # Output to device (quad)",
  "  od <adr> <val>...               # Output to device (double)",
  "  ow <adr> <val>...               # Output to device (word)",
  "  oh <adr> <val>...               # Output to device (half)",
  "  ob <adr> <val>...               # Output to device (byte)",
  "",
  "    The degugger outputs the specified data <val>... to the devices ",
  "    after the specified address <adr>.",
  "    Unlike sq/sd/sw/sh/sb, the dot address is not updated.",
  "-L1",
  "-Ej register",
  " dr [-<cpuid>] [-[hfxw]*] [<reg>]...  # レジスタの表示",
  " sr [<reg> [<val>]]...                # レジスタの設定",
  " rload <fname>                        # レジスタのロード",
  " rsave <fname> [<reg>]...             # レジスタのセーブ",
  "-Ee register",
  " dr [-<cpuid>] [-[hfxw]*] [<reg>]...  # Register display",
  " sr [<reg> [<val>]]...                # Register setting",
  " rload <fname>                        # Register loading",
  " rsave <fname> [<reg>]...             # Register saving",
  "-Ij register",
  " dr [<reg>]...                  # レジスタの表示",
  " sr [<reg> [<val>]]...          # レジスタの設定",
  " rload <fname>                  # レジスタのロード",
  " rsave <fname> [<reg>]...       # レジスタのセーブ",
  "-Ie register",
  " dr [<reg>]...                  # Register display",
  " sr [<reg> [<val>]]...          # Register setting",
  " rload <fname>                  # Register loading",
  " rsave <fname> [<reg>]...       # Register saving",
  "-L2",
  "-Ej dr",
  "  dr [-<cpuid>] [-[hfxw]*] [<reg>]...",
  "                                  # レジスタの表示",
  "",
  "    <reg> には レジスタ名または、レジスタのグループ名を指定します。",
  "    指定できるレジスタグループ名は以下のとおりです。",
  "    ",
  "    レジスタグループ名  内容",
  "    gpr                 General Purpose Registers",
  "    hls                 HI、LO、HI1、LO1、SA",
  "    scr                 System Coprocessor Registers",
  "    pcr                 Performance Counter Registers",
  "    hdr                 Hardware Breakpoint Registers",
  "    fpr                 Floating Point Registers",
  "    fpc                 Floating Point Control Registers",
  "    vu0f                VU0 Floating Registers",
  "    vu0i                VU0 Integer Registers",
  "    vu1f                VU1 Floating Registers",
  "    vu1i                VU1 Integer Registers",
  "",
  "    なお、汎用レジスタについてはレジスタ番号形式 (例: $a0 は $4)も",
  "    使用可能です。",
  "",
  "    -<cpuid> オプションには以下のいずれかを指定できます。",
  "",
  "      -cpu    <reg> を省略した時に CPU レジスタを表示対象とします。[default]",
  "",
  "              汎用レジスタと $lo、$hi、$sa、$PC、$cause、$status、",
  "              $badvaddr、 $badpaddr の下位 32 bit および $PC の前後の",
  "              逆アセンブル表示を行ないます。",
  "",
  "      -vu0    <reg> を省略した時に VU0 レジスタを表示対象とします。",
  "      -vu1    <reg> を省略した時に VU1 レジスタを表示対象とします。",
  "",
  "              VI00-VI16,TPC,FBRST,VPU-STAT レジスタおよび TPC 前後の",
  "              逆アセンブル表示を行ないます。",
  "",
  "    $PC は疑似レジスタで $epc、$errorepc、$status、$cause の 4 つの",
  "    レジスタ値から計算されたプログラムカウンタの値を持ちます。",
  "",
  "    -[hfxw]* オプションで fpr,vu0f,vu1f レジスタの値の表示指定ができます。",
  "",
  "      -h    32bit 値を 16 進数で表示します。(fpr,vu0f,vu1f) [default]",
  "      -f    32bit 値を浮動小数で表示します。(fpr,vu0f,vu1f)",
  "      -x    vu0f,vu1f の表示順序を XYZW 順で表示します。(vu0f,vu1f)",
  "      -w    vu0f,vu1f の表示順序を WZYX 順で表示します。(vu0f,vu1f) [default]",
  "-Ee dr",
  "  dr [-<cpuid>] [-[hfxw]*] [<reg>]...",
  "                                  # Register display",
  "",
  "    Specify the register name or the group name of the register in ",
  "    <reg>.  The specifiable register group names are as follows. ",
  "    ",
  "    Register Group Name        Description",
  "    gpr                        General Purpose Registers",
  "    hls                        HI,LO,HI1,LO1,SA",
  "    scr                        System Coprocessor Registers",
  "    pcr                        Performance Counter Registers",
  "    hdr                        Hardware Breakpoint Registers",
  "    fpr                        Floating Point Registers",
  "    fpc                        Floating Point Control Registers",
  "    vu0f                       VU0 Floating Registers",
  "    vu0i                       VU0 Integer Registers",
  "    vu1f                       VU1 Floating Registers",
  "    vu1i                       VU1 Integer Registers",
  "",
  "    For general purpose registers, the register number format ",
  "    (e.g. $a0 is $4) is also usable. ",
  "",
  "    To -<cpuid> option, any of the following can be specified.",
  "",
  "      -cpu    Displays the CPU register when <reg> is omitted. [default]",
  "",
  "              Displays the lower 32 bits of general purpose registers, ",
  "              $lo, $hi, $sa, $PC, $cause, $status, $badvaddr, $badpaddr,",
  "              and disassembles the addresses before and after the $PC.",
  "",
  "      -vu0    Displays the VU0 register when <reg> is omitted.",
  "      -vu1    Displays the VU1 register when <reg> is omitted.",
  "",
  "              Displays VI00-VI16, TPC, FBRST and VPU-STAT registers, and ",
  "              disassembles and displays the addresses before and after ",
  "              the address shown with the TPC.",
  "              ",
  "    ",
  "    The $PC is a pseudo register and has a program counter value ",
  "    calculated from the values of four registers; $epc, $errorepc, ",
  "    $status, and $cause.",
  "    ",
  "    With -[hfxw]* option, display of the fpr, vu0f and vu1f register ",
  "    values can be specified.",
  "",
  "      -h    Displays 32-bit value in hex. (fpr,vu0f,vu1f) [default]",
  "      -f    Displays 32-bit value in floating-point number. (fpr,vu0f,vu1f)",
  "      -x    Displays vu0f and vu1f in XYZW order. (vu0f,vu1f)",
  "      -w    Displays vu0f and vu1f in WZYX order. (vu0f,vu1f) [default]",
  "-Ij dr",
  "  dr [<reg>]...",
  "                                  # レジスタの表示",
  "",
  "    <reg> には レジスタ名または、レジスタのグループ名を指定します。",
  "    指定できるレジスタグループ名は以下のとおりです。",
  "    ",
  "    レジスタグループ名  内容",
  "    gpr                 General Purpose Registers",
  "    hl                  HI、LO",
  "    scc                 System Coprocessor Registers",
  "    c2r                 coprocssor 2 (GTE) registers",
  "    c2c                 coprocssor 2 (GTE) control registers",
  "    gte                 all GTE registers (cop2,cp2)",
  "",
  "    なお、汎用レジスタについてはレジスタ番号形式 (例: $a0 は $4)も",
  "    使用可能です。",
  "",
  "    <reg> を省略した場合には汎用レジスタと $lo、$hi、$PC、$bada および",
  "    $PC 前後の逆アセンブル表示を行います。",
  "",
  "    $PC は疑似レジスタで $epc と $sr の 2 つのレジスタ値から",
  "    計算されたプログラムカウンタの値を持ちます。",
  "-Ie dr",
  "  dr [<reg>]...                  # Register display",
  "",
  "    To <reg>, specify a register name or a register group name.",
  "    The following are register group names wich can be registered.",
  "    ",
  "    Register Group Name        Contents",
  "    gpr                        General Purpose Registers",
  "    hl                         HI,LO",
  "    scc                        System Coprocessor Registers",
  "    c2r                        coprocssor 2 (GTE) registers",
  "    c2c                        coprocssor 2 (GTE) control registers",
  "    gte                        all GTE registers (cop2,cp2)",
  "",
  "    For general purpose registers, the register number format ",
  "    (e.g. $a0 is $4) is also usable.",
  "",
  "    If ommit <reg>, then display general purpose registers and $lo, $hi,",
  "    $PC, $bada, and disassemble before and after the $PC.",
  "",
  "    The $PC is a pseudo register and has a program counter value",
  "    calculated from the values of $epc and $sr.",
  "--j sr",
  "  sr [<reg> [<val>]]...           # レジスタの設定",
  "",
  "    <reg> で指定されたレジスタに値 <val> を設定します。",
  "--e sr",
  "  sr [<reg> [<val>]]...           # Register setting",
  "",
  "    This command sets a value <val> to the register specified in <reg>.",
  "--j rload",
  "  rload <fname>                   # レジスタのロード",
  "",
  "    指定されたファイル <fname> からレジスタ値をロードします。",
  "    一般には rsave コマンドでセーブしたファイル名を指定します。",
  "--e rload",
  "  rload <fname>                   # Register loading",
  "",
  "    This command loads the register value from the specified file <fname>.",
  "    In ordinary cases, the file name saved with the rsave command is specified. ",
  "--j rsave",
  "  rsave <fname> [<reg>]...        # レジスタのセーブ",
  "",
  "    指定されたファイル <fname> に指定レジスタ <reg>... の",
  "    レジスタ名と値をセーブします。",
  "    <reg>... を省略すると dr の省略時と同じレジスタをセーブします。",
  "--e rsave",
  "  rsave <fname> [<reg>]...        # Register saving",
  "",
  "    This command saves the register name and value in the specified ",
  "    register <reg>... in the specified file <fname>",
  "",
  "    When <reg>... is omitted, the same register that is saved in ",
  "    the case of dr default is saved.",
  "-L1",
  "--j module",
  " mload <fname> [<args>]...          # ターゲットプログラムモジュールのロード",
  " mstart [-d] [<fname> [<args>]...]  # ターゲットプログラムモジュールの実行",
  " mlist [-m] [-i] [-l]               # モジュールの一覧表示",
  " memlist [-s] [-f] [-a <adr>] [-r <range>]",
  "                                    # メモリリストの一覧表示",
  "--e module",
  " mload <fname> [<args>]...         # Target program module load",
  " mstart [-d] [<fname> [<args>]...] # Target program module execution",
  " mlist [-m] [-i] [-l]              # Display module list",
  " memlist [-s] [-f] [-a <adr>] [-r <range>]",
  "                                   # Display memory block list",
  "-L2",
  "--j mload",
  "  mload <fname> [<args>]...       # ターゲットプログラムモジュールのロード",
  "",
  "    指定実行ファイル <fname> をターゲットのメモリへロードし、開始アドレス",
  "    などの情報をデバッガ内部に保存します。<args>... は実行時にターゲット",
  "    プログラムへ引数として渡されます。",
  "--e mload",
  "  mload <fname> [<args>]...       # Target program module load",
  "",
  "    The debugger loads the specified execution file <fname> into ",
  "    the memory of the target, stores information on the start address ",
  "    etc. inside the debugger.  ",
  "    <args>... is passed to the target program as an argument during ",
  "    execution.",
  "--j mstart",
  "  mstart [-d] [<fname> [<args>]...]",
  "                                  # ターゲットプログラムモジュールの実行",
  "",
  "    プログラムモジュールのエントリポイントを呼び出します。すでに mload を",
  "    行っている場合は引数なしで呼び出せます。 mload を行っていない場合は、",
  "    引数にファイル名を指定することでプログラムモジュールのロードとエントリ",
  "    ポイントを呼び出します。",
  "",
  "    -d オプションをつけるとデバックモードでエントリポイントを呼び出します。",
  "    具体的には、ブレークポイントを設定し、エントリポイントを呼び出し",
  "    プログラムモジュールから戻ってくるまで画面にはターゲットプログラムからの",
  "    標準出力が表示されます。",
  "    program の中断は CTRL-C、中断しないで debugger に制御を戻すには",
  "    CTRL-G を入力します。",
  "--e mstart",
  "  mstart [-d] [<fname> [<args>]...]",
  "                                  # Target program module execution",
  "",
  "    Call the entry point of the program module.  In case where mload is already",
  "    executed, it can be called without an argument.  When mload is not executed,",
  "    specifying the file name to the argument results in calling the program ",
  "    module load and the entry point.",
  "",
  "    If a -d option is added, an entry point is called in the debug mode.",
  "    Specifically, it sets the breakpoint and calls the entry point and ",
  "    the standard output is displayed on a screen until returning from the ",
  "    program module. To suspend a program, enter CTRL-C.  To return the ",
  "    control to the debugger without stopping, enter CTRL-G.",
  "",
  "    If the -d option is not added, display the prompt immediately after booting",
  "    the program module.",
  "--j mlist",
  "  mlist [-m] [-i] [-l]            # モジュールの一覧表示",
  "",
  "    ターゲットのメモリ上に常駐しているモジュールの一覧を表示します。",
  "",
  "    -i オプションを指定すると mload/mstart コマンドでロードした",
  "    モジュールの一覧のみを表示します。",
  "",
  "    -m オプションは過去のバージョンとの互換性を持たせるためのもので、",
  "    指定されても単にその存在を無視します。",
  "",
  "    -l オプションを指定するとより長い形式の一覧を表示します。",
  "--e mlist",
  "  mlist [-m] [-i] [-l]            # Display module list",
  "",
  "    Displays list of the resident modules to the target memory.",
  "",
  "    If a -i option is added, displays only list of the modules which was",
  "    loaded by the mload/mstart commands.",
  "",
  "    The -m option is exists to only backward compatibility.",
  "    If a -m option is added, always it's simply ignored.",
  "",
  "   The -l option is added, displays by long format.",
  "--j memlist",
  "  memlist [-s] [-f] [-a <adr>] [-r <range>]",
  "                                  # メモリブロックの一覧表示",
  "",
  "    ターゲット上に存在するメモリブロックの一覧を表示します。",
  "",
  "    -s オプションを指定するとモジュール名は表示しません。",
  "",
  "    -f オプションを指定すると空きメモリブロックのみを表示します。",
  "",
  "    -a <adr> と -r <range> オプションで表示するメモリ範囲を指定する事も",
  "    できます。-r オプションを指定しない時の <range> の値は 1 [byte] です。",
  "",
  "    -a オプションを指定すると、そのメモリ範囲に含まれるもののみを表示します。",
  "--e memlist",
  "  memlist [-s] [-f] [-a <adr>] [-r <range>]",
  "                                  # Display memory block list",
  "",
  "    Displyas list of the memory block.",
  "",
  "    If a -s option is added, module name is not displayed.",
  "",
  "    If a -f option is added, display only free memory blocks.",
  "",
  "    Displayed range is can specified by -a <adr> and -r <range> options.",
  "    If ommit -r option, <range> is 1 [byte].",
  "",
  "    If a -a option is added, display only included by the specified range.",
  "-L1",
  "-Ej instruction",
  " sload [-id <id>] [-b <base>] [<fname>]",
  "                                 # プログラムのシンボルのみのロード",
  " di [-m <mark>] [<adr> [<cnt>]]  # 逆アセンブル表示",
  " vdi [-<cpuid>] [-m <mark>] [<adr> [<cnt>]]",
  "                                 # VU マイクロ命令の逆アセンブル表示",
  " as <adr> <inst>                 # 行単位の簡易アセンブラ",
  " list [<adr> [<cnt> [<back>]]]   # ソース行の表示",
  " bt [<cnt>]                      # バックトレースの表示",
  "-Ee instruction",
  " sload [-id <id>] [-b <base>] [<fname>]",
  "                                 # Program load limited to symbol",
  " di [-m <mark>] [<adr> [<cnt>]]  # Disassembly display",
  " vdi [-<cpuid>] [-m <mark>] [<adr> [<cnt>]]",
  "                                 # Disassembly display of VU microinstruction",
  " as <adr> <inst>                 # Simple assembler in line units",
  " list [<adr> [<cnt> [<back>]]]   # List source line",
  " bt [<cnt>]                      # Backtrace",
  "-Ij instruction",
  " sload [-id <id>] [-b <base>] [<fname>]",
  "                                 # プログラムのシンボルのみのロード",
  " di [-m <mark>] [<adr> [<cnt>]]  # 逆アセンブル表示",
  " as <adr> <inst>                 # 行単位の簡易アセンブラ",
  " list [<adr> [<cnt> [<back>]]]   # ソース行の表示",
  " bt [<cnt>]                      # バックトレースの表示",
  "-Ie instruction",
  " sload [-id <id>] [-b <base>] [<fname>]",
  "                                 # Program load limited to symbol",
  " di [-m <mark>] [<adr> [<cnt>]]  # Disassembly display",
  " as <adr> <inst>                 # Simple assembler in line units",
  " list [<adr> [<cnt> [<back>]]]   # List source line",
  " bt [<cnt>]                      # Backtrace",
  "-L2",
  "--j sload",
  "  sload [-id <id>] [-b <base>] [<fname>]",
  "                                  # プログラムのシンボルのみのロード",
  "",
  "    指定実行ファイル <fname> のシンボル情報をデバッガの内部の",
  "    シンボル情報に追加します。pload と異なりターゲットのメモリへのロード",
  "    は行ないません。",
  "",
  "    <fname> を省略するとデバッガ内部のシンボル情報をすべてクリアします。",
  "",
  "    -id <id> オプションと -b <base> オプションの可能な組合せおよび意味は",
  "    以下の通りです。",
  "",
  "        sload <fname>",
  "",
  "            モジュールファイル <fname> 中のモジュール名とバージョンで",
  "            ターゲットに問い合わせを行い、モジュールベースアドレスを",
  "            決定します。",
  "",
  "        sload -id <id> <fname>",
  "             ",
  "            指定されたモジュール ID <id> によるモジュールベースアドレス",
  "            を使用します。モジュールファイル <fname> 中のモジュール名と",
  "            バージョンがターゲットが持つ情報と一致しない場合にはエラーと",
  "            なります。",
  "",
  "        sload -b <base> <fname>",
  "",
  "            ターゲットへの問い合わせを行わずに指定されたモジュールベース",
  "            アドレス <base> を使用します。",
  "",
  "    -id オプションと -b オプションを同時に指定することはできません。",
  "--e sload",
  "  sload [-id <id>] [-b <base>] [<fname>]",
  "                                  # Program load limited to symbol",
  "",
  "    The debugger adds symbol information on the specified execution ",
  "    file <fname> to the symbol information in the debugger.  Unlike ",
  "    the pload, the debugger does not load the specified execution ",
  "    file <fname> into the memory ",
  "    of the target. ",
  "",
  "    When the <fname> is omitted, all the symbol information in ",
  "    the debugger is cleared. ",
  "",
  "    The following are valid combinations and meaning of -id, -b option.",
  "",
  "        sload <fname>",
  "",
  "            Query to target by module name and module version in module file",
  "            <fname>. Module base address is decided by answer from target.",
  "",
  "        sload -id <id> <fname>",
  "",
  "            Use module base address of specified ID <id>.",
  "            If lack of agreement with module name and module version in",
  "            module file <fname> and informations in target,",
  "            sload command is finished with error.",
  "",
  "        sload -b <base> <fname>",
  "",
  "            Unless query to target, use specified module base address <base>.",
  "",
  "    -id option and -b option can not used at the same time.",
  "--j di",
  "  di [-m <mark>] [<adr> [<cnt>]]  # 逆アセンブル表示",
  "",
  "    指定アドレス <adr> から逆アセンブル表示を行ないます。",
  "    <adr> のデフォルトはドットアドレス(現在のアドレス)です。",
  "    <cnt> は一度に表示する命令数で、デフォルトは 20 命令です。",
  "    -m <mark> が指定された場合はアドレス <mark> の行に \"->\" の",
  "    マークを表示します。",
  "--e di",
  "  di [-m <mark>] [<adr> [<cnt>]]  # Disassembly display",
  "",
  "    This command performs disassembly display from the specified ",
  "    address <adr>.",
  "    The default of <adr> is a dot address (current address).",
  "    <cnt> is the number of instructions displayed at a time, ",
  "    and 20 instructions are set as default. ",
  "    When -m <mark> is specified, the debugger displays \"->\" mark ",
  "    in the line of address <mark>. ",
  "-Ej vdi",
  "  vdi [-<cpuid>] [-m <mark>] [<adr> [<cnt>]]",
  "                                   # VU マイクロ命令の逆アセンブル表示",
  "",
  "    指定アドレス <adr> から 8 バイトずつのデータを VU のマイクロ命令",
  "    として逆アセンブル表示を行ないます。",
  "",
  "    -<cpuid> オプションには以下のいずれかを指定できます。",
  "",
  "      -cpu    指定アドレス空間を CPU のメインメモリ空間とします。[default]",
  "      -vu0    指定アドレス空間を uMEM0 空間とします。",
  "      -vu1    指定アドレス空間を uMEM1 空間とします。",
  "",
  "    <adr> のデフォルトはドットアドレス(現在のアドレス)です。",
  "    <cnt> は一度に表示する命令数で、デフォルトは 20 命令です。",
  "    -m <mark> が指定された場合はアドレス <mark> の行に \"->\" の",
  "    マークを表示します。",
  "-Ee vdi",
  "  vdi [-<cpuid>] [-m <mark>] [<adr> [<cnt>]]",
  "                                   # Disassembly display of ",
  "                                     VU microinstruction",
  "",
  "    This command performs disassembly display to the data in groups of ",
  "    eight bytes from the specified address <adr> as VU microinstruction. ",
  "",
  "    To -<cpuid> option, any of the following can be specified.",
  "",
  "      -cpu    Sets CPU main memory space as specified address space.  ",
  "              [default]",
  "      -vu0    Sets uMEM0 space as specified address space.",
  "      -vu1    Sets uMEM1 space as specified address space.",
  "",
  "    The default of <adr> is a dot address (current address). ",
  "    <cnt> is the number of instructions displayed at a time, and 20 ",
  "    instructions are set as default. ",
  "    When -m <mark> is specified, the debugger displays \"->\" mark in ",
  "    the line of address <mark>. ",
  "--j as",
  "  as <adr> <inst>                 # 行単位の簡易アセンブラ",
  "",
  "    指定アドレス <adr> に命令 <inst> を書き込みます。",
  "    たとえば以下のように指定します。",
  "",
  "      dsidb > as 10000 lw $v0,10($s0)",
  "--e as",
  "  as <adr> <inst>                 # Simple assembler in line units",
  "",
  "    This command writes an instruction <inst> to the specified address",
  "    <adr>.  The following is a specification example.",
  "",
  "      dsidb > as 10000 lw $v0,10($s0)",
  "--j list",
  "  list [<adr> [<cnt> [<back>]]]   # ソース行の表示",
  "",
  "    指定アドレス <adr> に該当する前後のソース行を表示します。",
  "    <adr> のデフォルト値は $PC です。",
  "",
  "    指定行数 <cnt> は表示するソース行数でデフォルトは 21 行です。",
  "",
  "    <back> は指定アドレスに該当するソース行と表示開始行との差分でデフォルトは",
  "    10 行です。(10 行前から表示を開始します)",
  "",
  "    list コマンド実行後に RET のみで継続を指定した場合には、最後に表示した",
  "    次のソース行から、最後に実行した表示行数分の表示を行います。",
  "",
  "    ソース行表示の左端の \"->\" は $PC に該当するソース行である事を示します。",
  "",
  "    ソース行表示を行うには実行ファイルを gcc -g で作成して下さい。",
  "--e list",
  "  list [<adr> [<cnt> [<back>]]]   # lists source codes",
  "",
  "    Display source lines around specified address <adr>.",
  "    The default of <adr> is $PC.",
  "",
  "    <cnt> is the number of display lines. The default of <cnt> is 21.",
  "",
  "    <back> is difference from specified line by <adr> to the start line.",
  "    The default of <back> is 10.",
  "",
  "    When input only RET (means conitinue last command), display from",
  "    next lines of last displayed, and the number of displayed lines",
  "    is same to the last.",
  "",
  "    The mark of \"->\" at left means to source line which correspondings to $PC.",
  "",
  "    To display source line, use \"gcc -g\".",
  "--j bt",
  "  bt [<cnt>]                      # バックトレースの表示",
  "",
  "    現在のプログラムカウンタからスタックフレームを遡り、スタックフレーム中の",
  "    プログラムカウンタ値を表示します。",
  "",
  "    スタックフレーム数 <cnt> が指定された場合にはその数だけ、指定がない",
  "    場合にはすべてのスタックフレームを表示します。",
  "",
  "    バックトレースを表示すると以下の疑似変数が設定され、以降のコマンドで",
  "    参照が可能となります。",
  "",
  "      $BT<n>   # バックトレースアドレス",
  "",
  "        <n> が 1 以上の場合はそのスタックフレームから該当する関数呼び出し命令",
  "        のアドレス。<n> が 0 の場合は $PC の値。",
  "",
  "      $SFA<n>  # スタックフレームアドレス",
  "",
  "        <n> 番目のスタックフレームの最小値。",
  "",
  "      $SFS<n>  # スタックフレームサイズ",
  "",
  "        <n> 番目のスタックフレームの最大値から最小値を引いた値。",
  "",
  "    例えば 2 番目のスタックフレーム位置に戻った場所にブレークポイントを",
  "    設定するには bp $BT2+0x8 のように指定します。",
  "",
  "    <n> 番目のスタックフレームを dw でダンプする命令 dsf を subst コマンドで",
  "    定義し、実行するには以下のように指定します。",
  "",
  "      dsedb > subst \"^dsf  *\\([0-9][0-9]*\\) *$\" dw $SFA\\1 $SFS\\1",
  "      dsedb > dsf 2",
  "--e bt",
  "  bt [<cnt>]                      # backtrace",
  "",
  "    Display program counters in stack frames by backtracing from current",
  "    program counter.",
  "",
  "    The number of stack frames is specified by <cnt>. If <cnt> is omitted,",
  "    display program counters in all stack frames.",
  "",
  "    The following pseudo variables are set by bt command.",
  "",
  "      $BT<n>   # Backtrace address",
  "",
  "        If <n> greater than 1, then calling address from specified stack frame.",
  "        If <n> is zero, then value of $PC.",
  "",
  "      $SFA<n>  # Stack frame address",
  "",
  "        The minimum value of specified stack frame.",
  "",
  "      $SFS<n>  # Stack frame size",
  "",
  "        (The maximum value of specified stack frame) - $SFA<n>",
  "",
  "    Example, \"bp $BT2+0x8\" means set breakpoint to address which returned",
  "    to second stack frame.",
  "",
  "    The following example is define 'dsf' command which dumps stack frame",
  "    by dw command using subst command, and execute dsf command.",
  "",
  "      dsedb > subst \"^dsf  *\\([0-9][0-9]*\\) *$\" dw $SFA\\1 $SFS\\1",
  "      dsedb > dsf 2",
  "-L1",
  "-Ej execution",
  " bp [<adr>[,<cnt>]]...           # ブレークポイントの設定",
  " ub [all|<adr>]...               # ブレークポイントの解除",
  " be [<adr>]...                   # ブレークポイントの有効化",
  " bd [<adr>]...                   # ブレークポイントの無効化",
  " hbp [{pc}[<uskx><nt>][:<adr>[,<amsk>]]]...",
  " hbp [{da|dr|dw}[<uskx><nt>][:<adr>[,<amsk>]=<val>[,<vmsk>]]]...",
  "                                 # ハードウエアブレークポイントの設定",
  " hub [{pc|da|dr|dw}]...          # ハードウエアブレークポイントの解除",
  " pload <fname> [<args>]...       # ターゲットプログラムのロード",
  " run [<fname> [<args>]...]       # ターゲットプログラムの実行",
  " cont [<cnt>]                    # ターゲットプログラムの継続",
  " step [<cnt>]                    # ターゲットプログラムのステップ実行",
  " next [<cnt>]                    # ターゲットプログラムのネクスト実行",
  " lstep [<cnt>]                   # ソース行単位でのステップ実行",
  " lnext [<cnt>]                   # ソース行単位でのネクスト実行",
  " luntil <line>                   # プログラムの指定ソース行までの実行",
  " until <adr>...                  # 一時的ブレークポイントによる継続実行",
  " break                           # ターゲットプログラムの中断",
  " wait                            # ターゲットプログラムの停止を待つ",
  "-Ee execution",
  " bp [<adr>[,<cnt>]]...           # Breakpoint setting",
  " ub [all|<adr>]...               # Breakpoint release",
  " be [<adr>]...                   # Validation of breakpoint",
  " bd [<adr>]...                   # Invalidation of breakpoint",
  " hbp [{pc}[<uskx><nt>][:<adr>[,<amsk>]]]...",
  " hbp [{da|dr|dw}[<uskx><nt>][:<adr>[,<amsk>]=<val>[,<vmsk>]]]...",
  "                                 # Hardware breakpoint setting",
  " hub [{pc|da|dr|dw}]...          # Hardware breakpoint release",
  " pload <fname> [<args>]...       # Target program load",
  " run [<fname> [<args>]...]       # Execution of target program",
  " cont [<cnt>]                    # Continuation of target program",
  " step [<cnt>]                    # Stepwise execution of target program",
  " next [<cnt>]                    # Next execution of target program",
  " lstep [<cnt>]                   # Step source line",
  " lnext [<cnt>]                   # Next source line",
  " luntil <line>                   # Continued execution to the specified ",
  "                                   source line by temporary breakpoint",
  " until <adr>...                  # Continued execution to the specified address                                   by temporary breakpoint",
  " break                           # Interrupt of target program",
  " wait                            # Wait for stop of the target program",
  "-Ij execution",
  " bp [<adr>[,<cnt>]]...           # ブレークポイントの設定",
  " ub [all|<adr>]...               # ブレークポイントの解除",
  " be [<adr>]...                   # ブレークポイントの有効化",
  " bd [<adr>]...                   # ブレークポイントの無効化",
  " hbp [{pc|da|dr|dw}[<ku>][:<adr>[,<amsk>]]]",
  "                                 # ハードウエアブレークポイントの設定",
  " hub [{pc|da|dr|dw}]...          # ハードウエアブレークポイントの解除",
  " cont [<cnt>]                    # ターゲットプログラムの継続",
  " step [<cnt>]                    # ターゲットプログラムのステップ実行",
  " next [<cnt>]                    # ターゲットプログラムのネクスト実行",
  " lstep [<cnt>]                   # ソース行単位でのステップ実行",
  " lnext [<cnt>]                   # ソース行単位でのネクスト実行",
  " luntil <line>                   # プログラムの指定ソース行までの",
  "                                   一時的ブレークポイントによる実行",
  " until <adr>...                  # プログラムの指定アドレスまでの",
  "                                   一時的ブレークポイントによる継続実行",
  " break                           # ターゲットプログラムの中断",
  " wait                            # ターゲットプログラムの停止を待つ",
  "-Ie execution",
  " bp [<adr>[,<cnt>]]...           # Breakpoint setting",
  " ub [all|<adr>]...               # Breakpoint release",
  " be [<adr>]...                   # Validation of breakpoint",
  " bd [<adr>]...                   # Invalidation of breakpoint",
  " hbp [{pc|da|dr|dw}[<ku>][:<adr>[,<amsk>]]]",
  "                                 # Hardware breakpoint setting",
  " hub [{pc|da|dr|dw}]...          # Hardware breakpoint release",
  " cont [<cnt>]                    # Continuation of target program",
  " step [<cnt>]                    # Stepwise execution of target program",
  " next [<cnt>]                    # Next execution of target program",
  " lstep [<cnt>]                   # Step source line",
  " lnext [<cnt>]                   # Next source line",
  " luntil <line>                   # Continued execution to the specified",
  "                                   source line by temporary breakpoint",
  " until <adr>...                  # Continued execution to the specified",
  "                                    address by temporary breakpoint",
  " break                           # Interrupt of target program",
  " wait                            # Wait for stop of the target program",
  "-L2",
  "--j bp",
  "  bp [<adr>[,<cnt>]]...           # ブレークポイントの設定",
  "",
  "    指定アドレス <adr> にブレークポイントを設定します。",
  "    引数を省略すると現在設定されているブレークポイントをすべて表示します。",
  "    カウント値 <cnt> はブレークポイントの指定通過回数で、",
  "    省略時には 1 となります。",
  "",
  "    ブレークポイントを設定するとそのアドレスに対応するブレークポイント",
  "    疑似変数 $BP<n> にそのアドレスが設定され、以降の ub コマンド等で",
  "    $BP<n> を用いた指定が可能となります。",
  "--e bp",
  "  bp [<adr>[,<cnt>]]...           # Breakpoint setting",
  "",
  "    This command sets the breakpoint in the specified address <adr>.",
  "    When the argument is omitted, the debugger shows all the breakpoints",
  "",
  "    When the breakpoint is set, a pseudo register $BP<n> is also set.",
  "    $BP<n> can be used instead of <adr> at ub command, etc.",
  "--j ub",
  "  ub [all|<adr>]...               # ブレークポイントの解除",
  "",
  "    指定アドレス <adr> のブレークポイントを解除します。",
  "    引数を省略するか all を指定すると、すべてのブレークポイントを解除します。",
  "--e ub",
  "  ub [all|<adr>]...               # Breakpoint release",
  "",
  "    This command releases the breakpoint in the specified address <adr>.",
  "    When the argument is omitted or all is specified, the debugger ",
  "    releases all the breakpoints. ",
  "--j be",
  "  be [<adr>]...                   # ブレークポイントの有効化",
  "",
  "    指定アドレス <adr> のブレークポイントを有効化します。",
  "    <adr> を省略するとすべてのブレークポイントを有効化します。",
  "--e be",
  "  be [<adr>]...                   # Validation of breakpoint",
  "",
  "    This command validates the breakpoint in the specified address <adr>.",
  "    When <adr> is omitted, all the breakpoints are validated.",
  "--j bd",
  "  bd [<adr>]...                   # ブレークポイントの無効化",
  "",
  "    指定アドレス <adr> のブレークポイントを無効化します。",
  "    <adr> を省略するとすべてのブレークポイントを無効化します。",
  "--e bd",
  "  bd [<adr>]...                   # Invalidation of breakpoint",
  "",
  "    This command invalidates the breakpoint in the specified address ",
  "    <adr>.",
  "    When <adr> is omitted, all the breakpoints are invalidated.",
  "-Ej hbp",
  "  hbp [{pc}[<uskx><nt>][:<adr>[,<amsk>]]]...",
  "  hbp [{da|dr|dw}[<uskx><nt>][:<adr>[,<amsk>]=<val>[,<vmsk>]]]...",
  "                                  # ハードウエアブレークポイントの設定",
  "",
  "     指定アドレス <adr> に対してハードウエアブレークポイントを設定します。",
  "     pc,da,dr,dw はハードウエアブレークポイントのアクセスタイプで",
  "     以下の意味を持ちます。",
  "",
  "       pc - プログラムカウンタ",
  "       da - データアクセス",
  "       dr - データリードアクセス",
  "       dw - データライトアクセス",
  "",
  "     da,dr,dw は一度に一つのみ設定できます。",
  "     <amsk> は指定アドレスに対するマスク値です。",
  "     <uskx> は CPU の動作モード指定で以下のいずれかです。",
  "",
  "       u    - user のみ",
  "       s    - supervisor のみ",
  "       k    - kernel のみ",
  "       x    - EXL mode のみ",
  "       uk   - user または kernel",
  "           ...",
  "       uskx - すべての動作モード",
  "",
  "     <nt> はトリガ信号発生の有無、およびトリガ発生時にブレークポイント例外を",
  "     発生させるかどうかの指定です。",
  "",
  "       無指定 - トリガ信号を発生させない。ブレークポイント例外を発生させる。",
  "       nt     - トリガ信号を発生させる。ブレークポイント例外を発生させない。",
  "       t      - トリガ信号を発生させる。ブレークポイント例外を発生させる。",
  "",
  "     {pc|da|dr|dw} 部分の省略はできません。",
  "     <adr> を省略するとそのタイプの前回のアドレス値となります。",
  "     <uskx> と <nt> をともに省略するとそのタイプの前回の動作モードとなります。",
  "",
  "     da,dr,dw の場合には、さらに指定データ値 <val> およびそのマスク値 <vmsk>",
  "     が指定可能です。",
  "",
  "     引数をすべて省略すると、現在のハードウエアブレークポイントを表示します。",
  "",
  "     指定例) アドレス 0x08000000 へのデータリードの場合",
  "",
  "       dsedb > hbp druskx:0x08000000",
  "-Ee hbp",
  "  hbp [{pc}[<uskx><nt>][:<adr>[,<amsk>]]]...",
  "  hbp [{da|dr|dw}[<uskx><nt>][:<adr>[,<amsk>]=<val>[,<vmsk>]]]...",
  "                                  # Hardware breakpoint setting",
  "",
  "     These commands set hardware breakpoints to the specified address ",
  "     <adr>.",
  "     Each of pc, da, dr and dw shows the access type to distinguish ",
  "     the hardware breakpoint and has the following meaning.",
  "",
  "       pc - program counter",
  "       da - data access",
  "       dr - data read access",
  "       dw - data write access",
  "",
  "     As for da, dr and dw, only 1 setting can be made at a time.",
  "     <amsk> is a mask value to the specified address.",
  "     <uskx> is the specification of CPU operation mode as follows.",
  "",
  "       u    - user only",
  "       s    - supervisor only",
  "       k    - kernel only",
  "       x    - EXL mode only",
  "       uk   - user and kernel",
  "           ...",
  "       uskx - all modes",
  "",
  "     <nt> is the specification of trigger signal and break point exception",
  "     controls.",
  "",
  "      not specify - disable trigger signal, enable break point exception.",
  "      nt          - enable trigger signal, disable break point exception.",
  "      t           - enable trigger signal, enable break point exception.",
  "",
  "     {pc|da|dr|dw} part cannot be omitted.",
  "     When <adr> is omitted, the last address of the same type is set.",
  "     When <uskx> and <nt> are both omitted, the operation mode of the same",
  "     type is set.",
  "",
  "     For da, dr and dw, specified data value <val> and its mask ",
  "     value <vmsk> can be specified additionally.",
  "     ",
  "     When all the arguments are omitted, the current hardware breakpoint ",
  "     is displayed.",
  "     Example) Data read access to 0x08000000",
  "",
  "       dsedb > hbp druskx:0x08000000",
  "-Ij hbp",
  "  hbp [{pc|da|dr|dw}[<ku>][:<adr>[,<amsk>]]]",
  "                                  # ハードウエアブレークポイントの設定",
  "",
  "     指定アドレス <adr> に対してハードウエアブレークポイントを設定します。",
  "     pc,da,dr,dw はハードウエアブレークポイントのアクセスタイプで",
  "     以下の意味を持ちます。",
  "",
  "       pc - プログラムカウンタ",
  "       da - データアクセス",
  "       dr - データリードアクセス",
  "       dw - データライトアクセス",
  "",
  "     da,dr,dw は一度に一つのみ設定できます。",
  "     <amsk> は指定アドレスに対するマスク値です。",
  "     <uk> は CPU の動作モード指定で以下のいずれかです。",
  "",
  "       u  - user",
  "       k  - kernel",
  "       uk - user または kernel",
  "     {pc|da|dr|dw} 部分の省略はできません。",
  "     <adr> を省略するとそのタイプの前回のアドレス値となります。",
  "     <uk> を省略するとそのタイプの前回の動作モードとなります。",
  "",
  "     引数をすべて省略すると、現在のハードウエアブレークポイントを表示します。",
  "     指定例) アドレス 0x08000000 へのデータリードの場合",
  "",
  "       dsidb > hbp druk:0x08000000",
  "-Ie hbp",
  "  hbp [{pc|da|dr|dw}[<ku>][:<adr>[,<amsk>]]]...",
  "                                  # Hardware breakpoint setting",
  "",
  "     Set the hardware breakpoint to the specified address <adr>. ",
  "     pc,da,dr and dw are access types of the hardware break point",
  "     with the below meanings.",
  "",
  "       pc - program counter",
  "       da - data access ",
  "       dr - data read access ",
  "       dw - data write access ",
  "",
  "     As for da, dr and dw, only 1 setting can be made at a time.",
  "     <amsk> is a mask value to the specified address.",
  "     <uk> is a CPU operation mode specification with the below meanings.",
  "   ",
  "       u  - user",
  "       k  - kernel",
  "       uk - user and kernel",
  "",
  "     {pc|da|dr|dw} part cannot be omitted.",
  "     When <adr> is omitted, the last address of the same type is set.",
  "     When <uk> is omitted, the operation mode of the same type is set.",
  "     ",
  "     When all the arguments are omitted, the current hardware breakpoint ",
  "     is displayed.",
  "",
  "     Example) Data read access to 0x08000000",
  "",
  "       dsidb > hbp druk:0x08000000",
  "--j hub",
  "  hub [{pc|da|dr|dw}]...          # ハードウエアブレークポイントの解除",
  "",
  "    指定されたタイプ {pc|da|dr|dw} のハードウエアブレークポイントを解除します。",
  "    引数をすべて省略すると、すべてのハードウエアブレークポイントを解除します。",
  "--e hub",
  "  hub [{pc|da|dr|dw}]...          # Hardware breakpoint release",
  "",
  "    This command releases the hardware breakpoint of the specified ",
  "    type {pc|da|dr|dw}.",
  "    When all the arguments are omitted, all the hardware breakpoints ",
  "    are released.",
  "-Ej pload",
  "  pload <fname> [<args>]...       # ターゲットプログラムのロード",
  "",
  "    指定実行ファイル <fname> をターゲットのメモリへロードし、開始アドレス",
  "    などの情報をデバッガ内部に保存します。<args>... は実行時に",
  "    ターゲットプログラムへ引数として渡されます。",
  "-Ee pload",
  "  pload <fname> [<args>]...       # Target program load",
  "",
  "    The debugger loads the specified execution file <fname> into ",
  "    the memory of the target, sores information on the start address ",
  "    etc. inside the debugger.  ",
  "    <args>... is passed to the target program as an argument during ",
  "    execution.",
  "-Ej run",
  "  run [<fname> [<args>]...]       # ターゲットプログラムの実行",
  "",
  "    プログラムを実行します。すでに pload を行っている場合は引数なしで",
  "    実行できます。",
  "    pload を行っていない場合は、引数にファイル名を指定することで実行を",
  "    開始します。",
  "    画面にはターゲットプログラムからの標準出力が表示されます。",
  "    program の中断は CTRL-C、中断しないで debugger に制御を戻す",
  "    には CTRL-G を入力します。",
  "-Ee run",
  "  run [<fname> [<args>]...]       # Execution of target program",
  "",
  "    This command executes the program.  If the pload has already been ",
  "    performed, the program can be executed without the argument. ",
  "    If the pload has not been performed, the debugger starts ",
  "    the program execution by specifying the file name to the argument. ",
  "    The standard output from the target program is displayed on ",
  "    the screen. ",
  "    Input CTRL-C to interrupt the program, and input CTRL-G to return ",
  "    the control to the debugger without interrupting the program. ",
  "--j cont",
  "  cont [<cnt>]                    # ターゲットプログラムの継続",
  "",
  "    ターゲットプログラムを現在の状態から継続実行します。",
  "    ブレークポイントに達するか、何らかの exception が発生するまで待ちます。",
  "    引数の <cnt> は継続回数の指定でデフォルトは 1 です。",
  "    画面にはターゲットプログラムからの標準出力が表示されます。",
  "    ターゲットプログラムの中断は CTRL-C、中断しないでデバッガに制御を戻す",
  "    には CTRL-G を入力します。",
  "--e cont",
  "  cont [<cnt>]                    # Continuation of target program",
  "",
  "    This command continuously executes the target program from ",
  "    the current state. ",
  "    The debugger waits until the breakpoint is reached or some exception ",
  "    is generated. ",
  "    The argument <cnt> is the specification of the continued number, and ",
  "    1 is set as default. ",
  "    The standard output from the target program is displayed on ",
  "    the screen.",
  "    Input CTRL-C to interrupt the target program, and input CTRL-G to ",
  "    return the control to the debugger without interrupting the program.",
  "--j step",
  "  step [<cnt>]                    # ターゲットプログラムのステップ実行",
  "",
  "    現在の $PC から指定回数 <cnt> (default は 1) のステップ実行を行ないます。",
  "    ステップ回数は CPU の命令数と一致しています。遅延分岐を含む場合もそれらを",
  "    CPU が実行するそのままの順序でステップ実行を行います。",
  "--e step",
  "  step [<cnt>]                    # Stepwise execution of target program",
  "",
  "    This command performs stepwise execution of the specified number ",
  "    <cnt> (default: 1) from the current $PC.  The step number corresponds ",
  "    to the number of CPU instructions.  The debugger performs stepwise ",
  "    execution according to the CPU's execution order even when the delay ",
  "    slot is included. ",
  "--j next",
  "  next [<cnt>]                    # ターゲットプログラムのネクスト実行",
  "",
  "    現在の $PC から指定回数 <cnt> (default は 1) のネクスト実行を行ないます。",
  "    ネクスト回数は CPU の命令数と一致しています。遅延分岐を含む場合もそれらを",
  "    CPU が実行するそのままの順序でネクスト実行を行います。",
  "    ステップ実行との違いは jal、jalr 命令による関数呼び出しの中までトレース",
  "    対象とするかどうかだけです。",
  "--e next",
  "  next [<cnt>]                    # Next execution of target program",
  "",
  "    This command performs next execution of the specified number ",
  "    <cnt> (default: 1) from the current $PC.  The next number corresponds ",
  "    to the number of CPU instructions.  The debugger performs next ",
  "    execution according to the CPU's execution order even when the delay ",
  "    slot is included. ",
  "    The only difference from the stepwise execution is whether the inside ",
  "    of the function call by jal or jalr instruction is treated as a ",
  "    trace object or not.",
  "--j lstep",
  "  lstep [<cnt>]                   # ソース行単位でのステップ実行",
  "",
  "    現在の $PC から指定行数 <cnt> (default は 1) のステップ実行を行います。",
  "",
  "    コマンド実行時、または内部の 1 命令ステップ実行後の $PC が行番号を",
  "    持たない場合にはその旨を表示し、コマンドを終了します。(デフォルト)",
  "",
  "    オプション変数 lstep_stop_at_no_line を設定すると行番号情報を",
  "    持たない場所でもエラーとならずに内部で行番号情報を持つ場所まで",
  "    ステップ実行を行います。",
  "",
  "    lstep を行うには実行ファイルを gcc -g で作成して下さい。",
  "--e lstep",
  "  lstep [<cnt>]                   # Step source line",
  "",
  "    This command performs source line basic stepwise execution of the specified",
  "    number <cnt> (default: 1) from the current $PC.",
  "",
  "    In the default, if $PC has no line when starting or after internal step,",
  "    display the reason and finish lstep command.",
  "",
  "    If the option lstep_stop_at_no_line is set, no line locations not cause",
  "    error, and internally step is executed until location which has line",
  "    information.",
  "    To step source line, use \"gcc -g\".",
  "--j lnext",
  "  lnext [<cnt>]                   # ソース行単位でのネクスト実行",
  "",
  "    現在の $PC から指定行数 <cnt> (default は 1) のネクスト実行を行います。",
  "",
  "    コマンド実行時、または内部の 1 命令ネクスト実行後の $PC が行番号を",
  "    持たない場合にはその旨を表示し、コマンドを終了します。(デフォルト)",
  "",
  "    オプション変数 lstep_stop_at_no_line を設定すると行番号情報を",
  "    持たない場所でもエラーとならずに内部で行番号情報を持つ場所まで",
  "    ネクスト実行を行います。",
  "",
  "    lnext を行うには実行ファイルを gcc -g で作成して下さい。",
  "--e lnext",
  "  lnext [<cnt>]                   # Next source line",
  "",
  "    This command performs source line basic next execution of the specified",
  "    number <cnt> (default: 1) from the current $PC.",
  "",
  "    In the default, if $PC has no line when starting or after internal next,",
  "    display the reason and finish lnext command.",
  "",
  "    If the option lstep_stop_at_no_line is set, no line locations not cause",
  "    error, and internally next is executed until location which has line",
  "    information.",
  "    To next source line, use \"gcc -g\".",
  "--j luntil",
  "  luntil <line>                   # 指定ソース行までの",
  "                                    一時的ブレークポイントによる実行",
  "",
  "    現在の $PC を含むソースの指定行 <line> まで、一時的ブレーク",
  "    ポイントを用いて実行を行ないます。この luntil コマンドは bp コマンド",
  "    によるブレークポイントの影響は受けません。",
  "--j until",
  "  until <adr>...                  # 指定アドレスまでの",
  "                                    一時的ブレークポイントによる継続実行",
  "",
  "    現在の $PC から指定アドレス <adr>... まで、その順序で一時的ブレーク",
  "    ポイントを用いて継続実行を行ないます。この until コマンドは bp コマンド",
  "    によるブレークポイントの影響は受けません。",
  "--e luntil",
  "  luntil <line>                   # Continued execution to the specified",
  "                                    source line by temporary breakpoint",
  "",
  "    This command performs continued execution to the specified line",
  "     <line> of source containing the current $PC by using a temporary",
  "    breakpoint. This \"luntil\" command is not affected by the ",
  "    breakpoint by the bp command. ",
  "--e until",
  "  until <adr>...                  # Continued execution to the specified",
  "                                    address by temporary breakpoint",
  "",
  "    This command performs continued execution from the current $PC ",
  "    to the specified address <adr>... by using a temporary breakpoint.  ",
  "    This \"until\" command is not affected by the breakpoint by the bp ",
  "    command. ",
  "--j break",
  "  break                           # ターゲットプログラムの中断",
  "",
  "    プログラムの実行を中断します。",
  "--e break",
  "  break                           # Interrupt of target program",
  "",
  "    This command interrupts execution of program.",
  "--j wait",
  "  wait                            # ターゲットプログラムの停止を待つ",
  "",
  "    プログラムが実行中の時に例外が発生するのを待ちます。",
  "--e wait",
  "  wait                            # Wait for stop of the target program",
  "",
  "    This command waits for an exception to be generated while the program ",
  "    is being executed. ",
  "-L1",
  "-Ej other",
  " reset [-i | <ebootp> [<ibootp>]]# ターゲットのリセット",
  " xgkt <fname> <cnt> [<off>]      # XGKICK トレースの開始",
  " dbgctl {vu0|vu1} {on|off}       # デバッグモードの設定",
  " storeimage <fname> <bp> <bw> <psm> <x> <y> <w> <h>",
  "                                 # GS イメージデータの保存",
  " bpfunc <adr>                    # ブレークポイント関数の設定",
  " set [all] [<var>[=<val>]]       # オプションの表示と設定",
  " alias [-r] [<name> [<value>]]   # 別名の表示、設定、削除",
  " subst [-r] [<pattern> <replace>...]",
  "                                 # コマンド入力行置換の表示、設定、削除",
  " source <fname>                  # ファイルからのコマンド実行",
  " ![<cmd> [<args>]...]            # シェル呼び出し",
  " cd [<directory>]                # カレントディレクトリの変更",
  " printf \"<fmt>\" [<args>]...      # 書式付きメッセージ出力",
  " record [[-a] <fname>]           # 画面出力内容の記録開始と終了",
  " if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                 # 条件付きコマンド実行",
  " repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                 # コマンドの繰り返し実行",
  " show [log|status|history|dbconf|symbol|mdebug] ...",
  "                                 # 内部情報の表示",
  " help [<keyword>]...             # ヘルプメッセージの表示",
  " quit                            # dsidb の終了",
  "-Ee other",
  " reset [-i | <ebootp> [<ibootp>]]# Target reset",
  " xgkt <fname> <cnt> [<off>]      # XGKICK trace start",
  " dbgctl {vu0|vu1} {on|off}       # Debug mode setting",
  " storeimage <fname> <bp> <bw> <psm> <x> <y> <w> <h>",
  "                                 # Store GS image data",
  " bpfunc <adr>                    # Break point function setting",
  " set [all] [<var>[=<val>]]       # Option display and setting",
  " alias [-r] [<name> [<value>]]   # Display, setting and deletion of alias",
  " subst [-r] [<pattern> <replace>...]",
  "                                 # Display, setting and deletion of ",
  "                                   command input line replacement",
  " source <fname>                  # Command execution from file",
  " ![<cmd> [<args>]...]            # Shell call",
  " cd [<directory>]                # Change of current directory",
  " printf \"<fmt>\" [<args>]...      # Message output with format",
  " record [[-a] <fname>]           # Start/end of recording contents of ",
  "                                   screen output",
  " if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                 # Conditional execution",
  " repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                 # Repetitive execution of command",
  " show [log|status|history|dbconf|symbol|mdebug] ...",
  "                                 # Display of internal information",
  " help [<keyword>]...             # Display of help message",
  " quit                            # End of dsidb ",
  "-Ij other",
  " reset [-i | <ebootp> [<ibootp>]]# ターゲットのリセット",
  " bpfunc <adr>                    # ブレークポイント関数の設定",
  " set [all] [<var>[=<val>]]       # オプションの表示と設定",
  " alias [-r] [<name> [<value>]]   # 別名の表示、設定、削除",
  " subst [-r] [<pattern> <replace>...]",
  "                                 # コマンド入力行置換の表示、設定、削除",
  " source <fname>                  # ファイルからのコマンド実行",
  " ![<cmd> [<args>]...]            # シェル呼び出し",
  " cd [<directory>]                # カレントディレクトリの変更",
  " printf \"<fmt>\" [<args>]...      # 書式付きメッセージ出力",
  " record [[-a] <fname>]           # 画面出力内容の記録開始と終了",
  " if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                 # 条件付きコマンド実行",
  " repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                 # コマンドの繰り返し実行",
  " show [log|status|history|dbconf|symbol|mdebug] ...",
  "                                 # 内部情報の表示",
  " help [<keyword>]...             # ヘルプメッセージの表示",
  " quit                            # dsidb の終了",
  "-Ie other",
  " reset [-i | <ebootp> [<ibootp>]]# Target reset",
  " bpfunc <adr>                    # Break point function setting",
  " set [all] [<var>[=<val>]]       # Option display and setting",
  " alias [-r] [<name> [<value>]]   # Display, setting and deletion of alias",
  " subst [-r] [<pattern> <replace>...]",
  "                                 # Display, setting and deletion of ",
  "                                   command input line replacement",
  " source <fname>                  # Command execution from file",
  " ![<cmd> [<args>]...]            # Shell call",
  " cd [<directory>]                # Change of current directory",
  " printf \"<fmt>\" [<args>]...      # Message output with format",
  " record [[-a] <fname>]           # Start/end of recording contents of ",
  "                                   screen output",
  " if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                 # Conditional execution",
  " repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                 # Repetitive execution of command",
  " show [log|status|history|dbconf|symbol|mdebug] ...",
  "                                 # Display of internal information",
  " help [<keyword>]...             # Display of help message",
  " quit                            # End of dsidb ",
  "-L2",
  "--j reset",
  "  reset [-i | <ebootp> [<ibootp>]] # ターゲットのリセット",
  "",
  "    すべてのブレークポイントを無効化し、シンボル情報をクリアした後に",
  "    ターゲット全体をリセットします。",
  "",
  "    -i オプションを指定すると initial_[ei]bootp 変数値を",
  "    current_[ei]bootp 変数に設定します。",
  "    EE 用ブートパラメータ <ebootp> を指定するとその値を",
  "    current_ebootp に設定します。",
  "    IOP 用ブートパラメータ <ibootp> を指定するとその値を",
  "    current_ibootp に設定します。",
  "    ターゲットのブートパラメータは current_[ei]bootp 変数値を使用します。",
  "",
  "    EEブートパラメータ一覧",
  "      bit 0 メモリコントローラバグ対策 (0:なし 1:あり)",
  "      bit 1 ディスク起動 (0:OFF 1:ON)",
  "      bit 2 予約 (0:固定)",
  "      bit 3 予約 (0:固定)",
  "      bit 4 コンポーネント出力 (0:RGB 1:Y/CrCb)",
  "      bit 5 メモリサイズ (0:128MB 1:32MB)",
  "      bit 6 スタックチェック機能 (0:無効 1:有効)",
  "",
  "    IOPブートパラメータ一覧",
  "      bit 0 EE (0:スタート 1:スタートしない)",
  "      bit 1 FILE IOサービス (0:あり 1:なし)",
  "      bit 2 予約 (0:固定)",
  "      bit 3 予約 (0:固定)",
  "      bit 4 printfの出力 (0:ON 1:OFF)",
  "      bit 5 hostファイルのアクセス (0:可能 1:不可)",
  "      bit 6 EEのDECI2通信 (0:可能 1:不可)",
  "      bit 7 IOPのリプレイス後のメモリサイズ (0:8MB, 1:2MB)",
  "      bit 8 リプレイスモード (0:開発用モード, 1:テスト用モード)",
  "",
  "--e reset",
  "  reset [-i | <ebootp> [<ibootp>]] # Target reset",
  "",
  "    This command resets the whole target after invalidating all ",
  "    the breakpoints and clearing symbol information.",
  "",
  "    When the -i option is specified, the initial_[ei]bootp value is ",
  "    set to the current_[ei]bootp variable.",
  "    When the boot parameter for the EE <ebootp> is specified, the value ",
  "    is set to the current_ebootp.",
  "    When the boot parameter for the IOP <ibootp> is specified, the value ",
  "    is set to the current_ibootp.",
  "    The boot parameter for the target uses the current_[ei]bootp ",
  "    value.",
  "",
  "     EE Boot Parameter",
  "       bit 0 memory controler bug (0:not fixed, 1:fixed)",
  "       bit 1 disk boot (0:no, 1:yes)",
  "       bit 2 reserved bit (0:fixed)",
  "       bit 3 reserved bit (0:fixed)",
  "       bit 4 component output (0:RGB 1:Y/CrCb)",
  "       bit 5 EE memory size (0:128MB 1:32MB)",
  "       bit 6 stack check (0:no 1:yes)",
  "",
  "     IOP Boot Parameter ",
  "       bit 0 EE (0:start, 1:stop)",
  "       bit 1 fileio service (0:disable ,1:enable)",
  "       bit 2 reserved bit (0:fixed)",
  "       bit 3 reserved bit (0:fixed)",
  "       bit 4 reserved bit (0:fixed)",
  "       bit 5 host file access (0:enable, 1:disable)",
  "       bit 6 EE deci2 communication (0:on, 1:off)",
  "       bit 7 IOP memory size after replace (0:8MB, 1:2MB)",
  "       bit 8 IOP replace mode (0:development mode, 1:test mode)",
  "",
  "-Ej xgkt",
  "  xgkt <fname> <cnt> [<off>]      # XGKICK トレースの開始",
  "",
  "    VU1 の D-bit interrupt を用いて XGKICK 命令が指す GIF パケットデータを",
  "    指定ファイル <fname> に指定オフセット <off> から指定回数 <cnt> 分記録",
  "    します。<off> を省略した場合にはオフセットは 0 となります。",
  "    現在のバージョンでこの機能を使用するには、XGKICK 命令の upper 命令に",
  "    D-bit をあらかじめたてておく必要があります。",
  "-Ee xgkt",
  "  xgkt <fname> <cnt> [<off>]      # XGKICK trace start",
  "",
  "    This command records the GIF packet data indicated by the XGKICK ",
  "    instruction into the specified file <fname> from the specified ",
  "    offset <off> for the specified number <cnt> by using the D-bit ",
  "    interrupt of the VU1.  When <off> is omitted, the offset becomes 0.",
  "    To use this function in the current version, it is necessary to ",
  "    set the D bit in advance to the upper instruction of the XGKICK ",
  "    instruction.",
  "-Ej dbgctl",
  "  dbgctl {vu0|vu1} {on|off}       # デバッグモードの設定",
  "",
  "    VU0,VU1 の D-bit 割り込みの設定を行います。",
  "    [vu0|vu1] で VU0,VU1 を指定し、D-bit 割り込みを許可する場合には on を、",
  "    禁止する場合には off を指定します。",
  "    xgkt コマンド実行時には dbgctl vu1 on を自動的に実行します。",
  "    現在のバージョンで D-bit によるマイクロプログラムを停止させたい場合は、",
  "    停止させたい命令の upper 命令に D-bit をあらかじめたてておく必要があり",
  "    ます",
  "-Ee dbgctl",
  "  dbgctl {vu0|vu1} {on|off}       # Debug mode setting",
  "",
  "    This command sets the D-bit interrupt of the VU0 and VU1.",
  "    Specify VU0 or VU1 in [vu0|vu1].  Then specify \"on\" to enable ",
  "    the D-bit interrupt, and specify \"off\" to disable it.  ",
  "    When executing the xgkt command, \"dbgctl vu1 on\" is automatically ",
  "    executed.",
  "    To stop the microprogram by the D bit in the current version, it is ",
  "    necessary to set the D bit in advance to the upper instruction of the ",
  "    desired instructon.",
  "-Ej storeimage",
  "  storeimage <fname> <bp> <bw> <psm> <x> <y> <w> <h>",
  "                                  # GS イメージデータの保存",
  "   ",
  "    指定されたパラメータで GS イメージデータを読みだし、指定ファイル <fname>",
  "    に保存します。",
  "",
  "      bp",
  "        転送バッファベースアドレス (bp x 64 が実際のアドレスになります)",
  "",
  "      bw",
  "        転送バッファ幅 (bw x 64 が実際の幅になります)",
  "",
  "      psm",
  "        転送データのピクセルフォーマット",
  "          0 : PSMCT32  (ピクセルサイズ:32bit)",
  "          1 : PSMCT24  (ピクセルサイズ:24bit)",
  "          2 : PSMCT16  (ピクセルサイズ:16bit)",
  "          10: PSMCT16S (ピクセルサイズ:16bit)",
  "          19: PSMT8    (ピクセルサイズ:8bit)",
  "          20: PSMT4    (ピクセルサイズ:4bit)",
  "          27: PSMT8H   (ピクセルサイズ:8bit)",
  "          36: PSMT4HL  (ピクセルサイズ:4bit)",
  "          44: PSMT4HH  (ピクセルサイズ:4bit)",
  "          48: PSMZ32   (ピクセルサイズ:32bit)",
  "          49: PSMZ24   (ピクセルサイズ:24bit)",
  "          50: PSMZ16   (ピクセルサイズ:16bit)",
  "          58: PSMZ16S  (ピクセルサイズ:16bit)",
  "",
  "      x, y",
  "        転送領域の左上端点",
  "",
  "      w, h",
  "        転送領域の幅、高さ(ピクセル単位)",
  "",
  "    イメージデータのサイズ(w×h×ピクセルサイズ)は、16byte の倍数で",
  "    32767×16byte 以下でなければなりません。また、ピクセルサイズが 8bit の",
  "    場合は x,w はともに 2 の倍数、ピクセルサイズが 4bit の場合は x,w はともに",
  "    4 の倍数でなければなりません。",
  "-Ee storeimage",
  "  storeimage <fname> <bp> <bw> <psm> <x> <y> <w> <h>",
  "                                  # Store GS image data",
  "   ",
  "    Read GS image data with specified parameters, and save to file <fname>.",
  "",
  "      bp",
  "        Transfer buffer base address (bp x 64 is used address).",
  "",
  "      bw",
  "        Transfer buffer width (bw x 64 is used width).",
  "",
  "      psm",
  "        Pixel format of transfer data.",
  "          0 : PSMCT32  (pixel size:32bit)",
  "          1 : PSMCT24  (pixel size:24bit)",
  "          2 : PSMCT16  (pixel size:16bit)",
  "          10: PSMCT16S (pixel size:16bit)",
  "          19: PSMT8    (pixel size:8bit)",
  "          20: PSMT4    (pixel size:4bit)",
  "          27: PSMT8H   (pixel size:8bit)",
  "          36: PSMT4HL  (pixel size:4bit)",
  "          44: PSMT4HH  (pixel size:4bit)",
  "          48: PSMZ32   (pixel size:32bit)",
  "          49: PSMZ24   (pixel size:24bit)",
  "          50: PSMZ16   (pixel size:16bit)",
  "          58: PSMZ16S  (pixel size:16bit)",
  "",
  "      x, y",
  "        upper left point of transfer area.",
  "",
  "      w, h",
  "        width and height of transfer area (in pixel).",
  "",
  "    Image data size (w x h x pixel size) must be multiples of 16bytes",
  "    and not exceeding 32767 x 16 bytes. ",
  "    x and w must be multiples of 2 when pixel size is 8bit.",
  "    x and w must be multiples of 4 when pixel size is 4bit.",
  "--j bpfunc",
  "  bpfunc <adr>                    # ブレークポイント関数の設定",
  "",
  "    ブレークポイントを通過する際に実行される関数 <adr> を設定します。",
  "    <adr> に 0 が指定された場合には設定の解除となります。",
  "--e bpfunc",
  "  bpfunc <adr>                    # Break point function setting",
  "",
  "    Set break point function which is executed at passing break point.",
  "--j set",
  "  set [all] [<var>[=<val>]]       # オプション/ユーザ変数の表示と設定",
  "",
  "    デフォルト値から変更されたオプションのみを表示するには set だけを",
  "    指定します。すべてのオプションを表示するには set all と指定します。",
  "    オプションが文字列か数値を値として持つ場合に、オプション名 <var> の",
  "    値を <val> に設定するには set <var>=<val> と指定します。",
  "    オプションがブール値を持つ場合に、true の値に設定するには",
  "    set <var> を指定し、false の値を設定するには set no<var> と指定します。",
  "",
  "    set コマンドにはユーザ変数の表示と設定機能もあります。",
  "    ユーザ変数として使える変数名はオプション名に含まれずかつ dsidb の",
  "    レジスタ名でもない名前です。ユーザ変数は常に 32bit の数値を値として持ち、",
  "    all を指定しない時でも常に表示されます。ユーザ変数値への参照は表現式中で",
  "    $<var> の形式で可能です。",
  "    ユーザ変数に対して set <var>= のように <val> を省略すると、そのユーザ",
  "    変数を削除します。",
  "--e set",
  "  set [all] [<var>[=<val>]]       # Option/User-variable display and setting",
  "",
  "    To display only the option changed from the default value, specify ",
  "    \"set\" only.  ",
  "    To display all the options, specify \"set all\". ",
  "    To set the option name <var> to the <val> when the option has ",
  "    a character string or a numeric value as a value, specify ",
  "    \"set <var>=<val>\".",
  "    Specify \"set <var>\" for a true value setting and specify ",
  "    \"set no <var>\" for a false value when the option has a Boolean value. ",
  "",
  "    Set command has functions of display and setting user-variable, too.",
  "    User-variable name must be not option name and not register name.",
  "    User-variable has always 32bits numeric value, and always displayed",
  "    unless all option.",
  "    The referece to user-variable is possible by form of $<var> in expresion.",
  "    When ommit <var> like a \"set var=\" for user-variable, the user-variable",
  "    is removed.",
  "--j alias",
  "  alias [-r] [<name> [<value>]]   # 別名の表示、設定、削除",
  "",
  "    指定された別名 <name> がコマンド名として指定された時にコマンド文字列",
  "    <value> を実行します。",
  "    現在設定されているすべての別名を表示するには alias のみを指定します。",
  "    現在設定されているすべての別名を削除するには alias -r と指定します。",
  "    別名 <name> の設定のみを表示するには alias <name> と指定します。",
  "    新しい別名 <name> を <value> に設定するには alias <name> <value> と",
  "    設定します。<value> 中にはこの alias のみで使用可能な ${*} と ${N}",
  "    という表現が使え、${*} は実行時に指定された引数すべてに、${N} は",
  "    実行時に指定された N 番目の引数に展開されます。",
  "",
  "    <value> 中に複数のコマンドを指定するには alias dr2 (dr;dr) の",
  "    ように指定します。",
  "--e alias",
  "  alias [-r] [<name> [<value>]]   # Display, setting and deletion of ",
  "                                    alias",
  "",
  "    The debugger executes the command character string <value> when ",
  "    the specified alias <name> is specified as a command name. ",
  "    To display all the aliases currently set, specify only ",
  "    the \"alias\". ",
  "    To delete all the aliases currently set, specify the ",
  "    \"alias -r\". ",
  "    To display only the alias <name> setting, specify \"alias <name>\".",
  "    To set a new alias <name> to the <value>, set \"alias <name> ",
  "    <value>\".  ",
  "    In the <value>, expressions only useable for this alias such as ",
  "    ${*} and ${N} are available.  The ${*} is expanded to all ",
  "    the arguments specified during execution, and the ${N} is expanded ",
  "    to the Nth argument specified during execution.",
  "",
  "    To specify multiple commands, specify like a \"alias dr2 (dr;dr)\".",
  "--j subst",
  "  subst [-r] [<pattern> <replace>...]",
  "                                  # コマンド入力行置換の表示、設定、削除",
  "",
  "    コマンド入力行を文字列として扱い、その文字列中に含まれるパターン",
  "    <pattern> をすべて置換文字列 <replace>... で置き換えます。",
  "    現在設定されているすべての置換を表示するには subst のみを指定します。",
  "    現在設定されているすべての置換を削除するには subst -r と指定します。",
  "    現在設定されている <pattern> <replace>... の置換を削除するには",
  "    subst -r <pattern> <replace>... と指定します。",
  "    alias とは異なり同じ <pattern> への置換が設定されていた場合にも",
  "    前の設定を削除することは行いません。また <replace>... が省略された場合には",
  "    空の文字列への置換 (つまり削除) の設定となります。",
  "    複数の置換定義がある場合、指定された順序ですべてが適用されます。",
  "    ",
  "    <pattern> は一般には '\"' で囲まれた文字列形式で指定しますが、空白を",
  "    含まない場合には前後の '\"' は省略しても構いません。",
  "    <pattern> は以下の正規表現で指定します。",
  "",
  "      X        文字 X (X が以下の表現に含まれない場合)",
  "      \\X       文字 X (X が '(',')' でない場合)",
  "      .        任意の 1 文字",
  "      X*       X の繰り返し (0 回の繰り返しを含む)",
  "      [abc]    'a','b','c' のいずれかの 1 文字",
  "      [x-y]    'x' から 'y' までのいずれかの 1 文字",
  "      [^abc]   'a','b','c' のいずれでもない 1 文字",
  "      ^        行の先頭 (<pattern> の先頭にある場合のみ一致)",
  "      $        行の最後 (<pattern> の最後のある場合のみ一致)",
  "      \\(       タグの開始記録",
  "      \\)       タグの終了記録",
  "",
  "    <replace>... は通常の文字列の他、以下の特殊文字も指定できます。",
  "",
  "      \\X       文字 X (X が '1'-'9' でない場合)",
  "      &        現在一致している文字列全体",
  "      \\1       1 番目のタグ",
  "      \\2       2 番目のタグ",
  "               ...",
  "      \\9       9 番目のタグ",
  "",
  "    以下は指定例です。",
  "",
  "      ブレークポイント番号を $bp<n> で入力可能に設定する",
  "",
  "        dsidb> subst \"$bp\\([0-9]*\\)\" $BP\\1",
  "",
  "      show history を単に history だけで実行可能と設定する",
  "",
  "        dsidb> subst \"^ *history *$\" show history",
  "",
  "    コマンド入力行の先頭が '\\' である時には置換処理は行いません。",
  "    間違って subst \".*\" のような設定をしてしまった時には、たとえば \\quit",
  "    と入力すれば常に quit を実行できます。",
  "--e subst",
  "  subst [-r] [<pattern> <replace>...]",
  "                                  # Display, setting and deletion of ",
  "                                    command input line replacement",
  "",
  "    This command handles a command input line as a character string, and ",
  "    replaces all the patterns <pattern> included in the character string ",
  "    with a replacement character string <replace>...  ",
  "    ",
  "    To display all the currently-set replacements, specify the subst only. ",
  "    To delete all the currently-set replacements, specify the subst -r.",
  "    To delete the currently-set replacement of <pattern> with ",
  "    <replace>..., specify the subst -r <pattern> <replace>...",
  "    Unlike the alias, this command does not delete the previous setting ",
  "    even when the replacement to the same <pattern> has been set.",
  "    Furthermore, when <replace>... is omitted, replacement to an empty ",
  "    character string (i.e. deletion) is set.",
  "    In the case of two or more replacement definitions, all are applied ",
  "    in the order they have been specified.",
  "    ",
  "    The <pattern> is normally specified by the character string format ",
  "    surrounded by '\"'.  When no space is included, however, the '\"' ",
  "    surrounding the character string can be omitted.",
  "    The <pattern> is specified according to the formal expressions below.",
  "",
  "      X        Character X (when X is excluded from the expressions below.)",
  "      \\X       Character X (when X is not '(',')'.)",
  "      .        One optional character",
  "      X*       Repetition of X (including 0-time repetition)",
  "      [abc]    One of 'a', 'b' and 'c' characters",
  "      [x-y]    One of characters from 'x' to 'y'",
  "      [^abc]   One character other than 'a','b' and 'c'",
  "      ^        Start of line (corresponds only when it is at the start ",
  "               of <pattern>.)",
  "      $        End of line (corresponds only when it is at the end of ",
  "               <pattern>.)",
  "      \\(       Start record of tag",
  "      \\)       End record of tag",
  "",
  "    <replace>... can be specified with the following special characters ",
  "    as well as the ordinary character strings.",
  "",
  "      \\X       Character X (when X is not '1'-'9')",
  "      &        The whole character strings corresponding currently",
  "      \\1       1st tag",
  "      \\2       2nd tag",
  "               ...",
  "      \\9       9th tag",
  "",
  "    The following are specification examples.",
  "",
  "      Enable the breakpoint number to be input with $bp<n>.",
  "",
  "        dsidb> subst \"$bp\\([0-9]*\\)\" $BP\\1",
  "",
  "       Set the show history executable only with history.",
  "",
  "        dsidb> subst \"^ *history *$\" show history",
  "",
  "    When the start of the command input line is '\\', no replacement ",
  "    processing is performed.",
  "    When a setting such as subst \".*\" is made by mistake, for example, ",
  "    quit is always executable by inputting the \\quit.",
  "--j source",
  "  source <fname>                  # ファイルからのコマンド実行",
  "",
  "    指定ファイル <fname> の内容をコマンド列として実行します。",
  "",
  "    ファイル中の行の最後が '' である場合には次の行との連結が行われます。",
  "--e source",
  "  source <fname>                  # Command execution from file",
  "",
  "    This command executes the contents of the specified file <fname> ",
  "    as a command file. ",
  "",
  "    When the end of line is '\\', the line connected to next line.",
  "--j !",
  "  ![<cmd> [<args>]...]            # シェル呼び出し",
  "",
  "    '!' 以降のコマンド <cmd> および引数 <args>... をシェルに渡し",
  "    実行します。<cmd>、<args> は何も評価もせずにそのままシェルに渡します。",
  "    使用されるシェルは環境変数 SHELL によって決まり、設定されていない",
  "    場合には \"/bin/sh\" になります。",
  "    <cmd> を省略するとシェルそのものを呼び出します。",
  "--e !",
  "  ![<cmd> [<args>]...]            # Shell call",
  "",
  "    The debugger executes the commands <cmd> and arguments <args>... ",
  "    after '!' by passing them to the shell.  The debugger passes the ",
  "    <cmd> and <args> to the shell without giving any evaluation.",
  "    The shell to be used is decided by the environment variable SHELL.  ",
  "    When it is not set, it becomes \"/bin/sh\". ",
  "    When <cmd> is omitted, the debugger calls the shell itself.",
  "--j cd",
  "  cd [<directory>]                # カレントディレクトリの変更",
  "",
  "    カレントディレクトリを <directory> に変更します。引数が省略された",
  "    場合は環境変数 HOME で示されるディレクトリへ変更します。",
  "--e cd",
  "  cd [<directory>]                # Change of current directory",
  "",
  "    This command changes the current directory to the <directory>.  ",
  "    When the argument is omitted, the debugger changes the current ",
  "    directory to the directory shown by the environment variable HOME. ",
  "--j printf",
  "  printf \"<fmt>\" [<args>]...      # 書式付きメッセージ出力",
  "",
  "    メッセージを画面に出力します。",
  "    <fmt> には printf(3) と同じ書式が使えます。ただし floating 関係",
  "    (e,E,f,g) と %n は未サポートです。<args> は常に式として評価され、",
  "    その値が使われます。",
  "--e printf",
  "  printf \"<fmt>\" [<args>]...      # Message output with format",
  "",
  "    This command outputs the message on the screen.",
  "    The same format as printf(3) can be used for <fmt>.  However, e, E, ",
  "    f and g related to floating and %n are not supported.  The <args> ",
  "    is always evaluated as an expression, and the value is used. ",
  "--j record",
  "  record [[-a] <fname>]           # 画面出力内容の記録開始と終了",
  "",
  "    指定されたファイル <fname> に、以後の画面出力内容を保存します。",
  "    <fname> を省略すると記録の終了となります。",
  "    -a オプションを指定した場合はファイルには追加モードで書き込まれます。",
  "    記録終了せずに次の record を指定すると、自動的に前のファイルを",
  "    クローズします。",
  "--e record",
  "  record [[-a] <fname>]           # Start/end of recording contents of ",
  "                                    screen output",
  "",
  "    This command stores the contents of the succeeding screen outputs in ",
  "    the specified file <fname>. ",
  "    When the <fname> is omitted, recording ends. ",
  "    When the -a option is specified, write to the file is performed with ",
  "    Append A. ",
  "    When the following \"record\" is specified without ending ",
  "    the recording, the debugger automatically closes the previous file. ",
  "--j if",
  "  if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                  # 条件付きコマンド実行",
  "    条件付きでコマンドを実行します。",
  "",
  "    まず最初に if <expr> <cmd> の <expr> を評価し、その値が 0 ではない",
  "    場合に <cmd> を実行します。",
  "",
  "    if <expr> <cmd> の <expr> の値が 0 の時には elif や else 部分を評価し、",
  "    else の場合には無条件に、elif の場合には条件付きで <cmd> を実行します。",
  "--e if",
  "  if <expr> <cmd> [elif <expr> <cmd>]... [else <cmd>]",
  "                                  # Conditional execution of command",
  "",
  "    This command executes the specified command <cmd> with condition.",
  "",
  "    The first, (if <expr> <cmd>) is evaluated. If the value of <expr> is",
  "    not zero, the debugger executes <cmd>.",
  "",
  "    If the value of <expr> is zero, the part of 'elif' and 'else' are",
  "    evaluated. The part of 'else' is executed unconditionally.",
  "    The part of 'elif' is executed with condition.",
  "--j repeat",
  "  repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                  # コマンドの繰り返し実行",
  "",
  "    指定されたコマンド <cmd>... を繰り返し実行します。",
  "",
  "    繰り返し回数 <cnt> が -c オプションで指定されている場合には",
  "    その回数だけ、指定されていない場合にはエラーが発生するか CTRL-C が",
  "    入力されるまで無限に繰り返します。",
  "",
  "    繰り返し実行の間に、一度パケットの送受信処理等を行ないます。",
  "    -i オプションによる秒数 <sec> (デフォルト値は 1 [sec]) の時間内に",
  "    パケットの送受信やキー入力等がない場合には次の繰り返しを開始します。",
  "    もし、パケットの送受信またはキー入力があった時にはその時間を",
  "    待たずに次の繰り返しを実行します。",
  "",
  "    -while <expr> オプションが指定された場合には、<cmd>... の実行前に",
  "    その都度 <expr> を評価し、その値が 0 である時には repeat コマンド",
  "    を終了します。また -while オプションが指定され -i オプションが指定",
  "    されていない場合にはタイムアウト時間は 0 となります。",
  "",
  "    複数のコマンドを繰り返し実行するには repeat (dr;dr) のように指定します。",
  "--e repeat",
  "  repeat [-c <cnt>] [-i <sec>] [-while <expr>] <cmd>...",
  "                                  # Repetitive execution of command",
  "",
  "    This command executes the specified command <cmd>... repetitively. ",
  "",
  "    When the number of repetition <cnt> is specified by the -c option, ",
  "    the debugger repeats the command for the specified number.  When ",
  "    not specified, the debugger repeats the command infinitely until ",
  "    an error is generated or the CTRL-C is input.",
  "",
  "    The debugger performs the transmitting and receiving of a packet ",
  "    once during the repetitive execution. ",
  "    When there is no transmitting/receiving of a packet or key input ",
  "    within the seconds <sec> (default value: 1 [sec]) by the -i option, ",
  "    the debugger starts the following repetition.",
  "    When there is transmitting/receiving of a packet or key input, ",
  "    the debugger executes the following repetition without waiting ",
  "    for the specified time.",
  "",
  "    When the -while <expr> option is specified, The debugger evaluate",
  "    <expr> each time, Finish repeat command if the evaluated value is zero.",
  "    When -while option is specified and -i option is NOT specified,",
  "    the debugger set timeout value to zero.",
  "",
  "    To repeat multiple commands, specify like a \"repeat (dr;dr)\".",
  "--j show",
  "  show [log|status|history|dbconf|symbol] ...",
  "                                  # 内部情報の表示",
  "",
  "    show log ... で DECI2 パケットの送受信ログを表示します。",
  "",
  "    show log [[-]<option>]...",
  "    <option>:",
  "      l[ong]           時刻の差分、IP アドレス等も表示する",
  "      n[um]            DECI2 パケットをすべて 16 進で表示する",
  "      r[emove]         ログデータをすべて削除する",
  "      a[ll]            すべて表示する (tail,head との対比)",
  "      t[ail] <N>       最後の <N> 個だけ表示する",
  "      h[ead] <N>       最初の <N> 個だけ表示する",
  "      i[d] <ID>        <ID> に関するものだけ表示対象とする",
  "      m[sg] <msg>      <msg> に関するものだけ表示対象とする",
  "      p[roto] <proto>  プロトコル <proto> に関するものだけ表示対象とする",
  "      s[rc] <src>      送信元ノードが <src> に関するものだけ表示対象とする",
  "      d[st] <dst>      送信先ノードが <dst> に関するものだけ表示対象とする",
  "      v[erbose]        冗長モードによる表示",
  "",
  "      long、num は表示形式、remove は削除、all、tail、head は個数指定、",
  "      残りは表示条件で、複数指定は常に AND として解釈されます。",
  "",
  "    show status ... で内部ステータスの表示を行ないます。",
  "",
  "      show status [-m] [-d]",
  "",
  "      -m を指定するとメモリステータスを表示します。",
  "      -d を指定すると DECI2 を扱うすべての接続ステータスを表示します。",
  "      -m、-d がともに省略された場合は両方を表示します。",
  "",
  "    show history で過去の入力行の表示を行います。",
  "",
  "    show dbconf でターゲットから返された設定情報を表示します。",
  "",
  "    show symbol [<str>] でシンボル情報を表示します。",
  "    show mdebug [<str>] で mdebug 情報を表示します。",
  "",
  "      <str> が省略された場合にはすべての情報を表示します。",
  "      <str> が指定された場合には名前に <str> が含まれる情報のみを表示します。",
  "--e show",
  "  show [log|status|history|dbconf|symbol] ...",
  "                                  # Display of internal information",
  "",
  "    This command shows the transmitting/receiving log of the DECI2 ",
  "    packet with the show log .... ",
  "",
  "    show log [[-]<option>]...",
  "    <option>:",
  "      l[ong]            Displays difference in time, IP address, etc. ",
  "      n[um]             Displays all the DECI2 packets in hexadecimal.",
  "      r[emove]          Deletes all the log data. ",
  "      a[ll]             Displays all (comparison with tail and head). ",
  "      t[ail] <N>        Displays the last <N> packets only.",
  "      h[ead] <N>        Displays the first <N> packets only.",
  "      i[d] <ID>         Displays only <ID>-related items.",
  "      m[sg] <msg>       Displays only <msg>-related items. ",
  "      p[roto] <proto>   Displays only the items related to ",
  "                        protocol <proto>. ",
  "      s[rc] <src>       Displays only the items with <src>-related ",
  "                        source node. ",
  "      d[st] <dst>       Displays only the items with <dst>-related ",
  "                        destination node. ",
  "      v[erbose]         Display in verbose mode.",
  "",
  "      The long and num are display formats, remove is deletion, all, ",
  "      tail and head are specification of number, and the remainder are ",
  "      display conditions.  The specifications of two or more are ",
  "      always interpreted as AND. ",
  "",
  "    The debugger displays the internal status with the show status ....",
  "",
  "      show status [-m] [-d]",
  "",
  "      When the -m is specified, the debugger displays the memory status. ",
  "      When the -d is specified, the debugger displays all the connection ",
  "      status which handles the DECI2. ",
  "      When the -m and -d are both omitted, the debugger displays both.",
  "",
  "    The show history displays the input lines in the past.",
  "",
  "    The show dbconf displays the set information returned from the target.",
  "",
  "    The show symbol [<str>] displays the symbol information.",
  "    The show mdebug [<str>] displays the mdebug information.",
  "",
  "      When the <str> is omitted, all the information is displayed.",
  "      When the <str> is specified, only the name with <str> included ",
  "      are displayed.",
  "--j help",
  "  help [<keyword>]...             # ヘルプメッセージの表示",
  "",
  "    <cmd> を省略した場合には dsidb のコマンドの一覧を表示します。",
  "    コマンド名 <cmd> が指定された場合にはそのコマンドに関する",
  "    ヘルプのみを表示します。",
  "",
  "    キーワード <keyword> には以下が指定できます。",
  "",
  "      <cmd>",
  "         コマンド名 <cmd> に関するヘルプを表示します。",
  "",
  "      reg",
  "          指定可能なレジスタグループを表示します。",
  "",
  "      edit",
  "          行編集に使用可能なキーを表示します。",
  "",
  "      var",
  "          set コマンドで設定可能なオプション変数の一覧を表示します。",
  "",
  "      <var>",
  "          set コマンドで設定可能なオプション変数 <var> に関して表示します。",
  "",
  "      expr",
  "          使用可能な表現式に関して表示します。",
  "",
  "      keyword",
  "          help コマンドで指定できるすべてのキーワードを表示します。",
  "--e help",
  "  help [<keyword>]...             # Display of help message",
  "",
  "    Display command summary when <keyword> is omitted.",
  "    When the <keyword> is specified, the debugger displays",
  "    only the help concerning about the keyword.",
  "",
  "    The followings are specifiable as <keyword>.",
  "",
  "       <cmd>",
  "           Display about command <cmd>.",
  "",
  "       reg",
  "           Register group names.",
  "",
  "       edit",
  "           Edit keys for input line.",
  "",
  "       var",
  "           Option variable summary for set command.",
  "",
  "       <var>",
  "           Option variable <var> for set command.",
  "",
  "       expr",
  "           Expression syntax.",
  "",
  "       keyword",
  "           All keyword for help command.",
  "--j quit",
  "  quit                            # dsidb の終了",
  "",
  "    dsidb を終了します。",
  "--e quit",
  "  quit                            #  End of dsidb ",
  "",
  "    This command terminates the dsidb. ",
  "-L0",
  "--j var variable opt option",
  "  オプション名                値の形式    内容",
  "  ==================================================================",
  "  target_name                 文字列   dsnetm のホスト名およびポート   (OPTION)",
  "  tty_mask                    数値     ターゲットの TTYP 入出力の設定  (OPTION)",
  "  atty_mask                   数値     IOP/EE TTYP 表示の設定          (OPTION)",
  "  file_priority               数値     Remote File Access の優先順位   (OPTION)",
  "  reset_on_start              ブール   起動時のリセットの有無          (OPTION)",
  "  check_manager_version       ブール   manager version チェックの有無  (OPTION)",
  "  target_exec_ctl_config      数値     ターゲット実行制御の状態",
  "  target_exec_ctl_override    数値     ターゲット実行制御の上書き",
  "  dr_default_format           文字列   dr コマンドのデフォルト表示形式指定",
  "  dr_default_di               文字列   dr コマンド時の di 実行内容指定",
  "  ex_default_dr               文字列   例外発生時の dr 実行内容指定",
  "  dr0_default_di              文字列   dr -vu0 コマンド時の di 実行内容指定",
  "  ex0_default_dr              文字列   VU0 例外発生時の dr 実行内容指定",
  "  dr1_default_di              文字列   dr -vu1 コマンド時の di 実行内容指定",
  "  ex1_default_dr              文字列   VU1 例外発生時の dr 実行内容指定",
  "  lstep_default_list          文字列   lstep,lnext 実行後の list 実行指定",
  "  lstep_stop_at_no_line       数値     lstep,lnext で行番号がない場合に停止",
  "  source_directories          文字列   ソース探索ディレクトリリストの指定",
  "  initial_ebootp              文字列   EE 用ブートパラメータの初期値",
  "  current_ebootp              文字列   EE 用ブートパラメータの現在値",
  "  initial_ibootp              文字列   IOP 用ブートパラメータの初期値",
  "  current_ibootp              文字列   IOP 用ブートパラメータの現在値",
  "  automatic_prefix_breakpoint ブール   ブレークポイント番号形式への自動前置",
  "  describe_ub_all             ブール   ub で all 指定時のみに全削除を行う",
  "  di_address                  数値     di コマンドのアドレス表示方式",
  "  di_instruction_word         数値     di コマンドの命令ワードの表示方式",
  "  di_branch_address           数値     di コマンドの分岐アドレス表示方式",
  "  di_macro                    数値     di/as コマンドのマクロ命令制御",
  "  help_lang                   文字列   ヘルプ表示の言語",
  "  help_pager                  文字列   ヘルプ表示に使用するページャ",
  "  hex_radix                   ブール   数値を 0x なしで 16 進数とみなす",
  "  log_total_size              数値     送受信ログの最大合計バイト数",
  "  log_packet_size             数値     送受信ログのパケットごとの最大バイト数",
  "  histfile                    文字列   ヒストリセーブファイル名",
  "  histfilesize                数値     セーブするヒストリ数",
  "  histsize                    数値     ヒストリの上限数",
  "  tty_max_size                数値     TTY パケットの最大保留バイト数",
  "",
  "  dsidb は起動時に ~/.dsidbrc と ./.dsidbrc の存在をしらべ、それらの",
  "  ファイルが存在した時はその順序で起動時に自動実行ファイルとして実行します。",
  "",
  "  上記のオプションのうち (OPTION) と書かれているオプションはその自動実行",
  "  ファイル内の option 文によってのみ、設定可能なオプションで、起動後にのみ",
  "  意味を持つため、後から変更することはできません。",
  "  option の引数は set コマンドと同じ引数を持ちます。",
  "--e var variable opt option",
  "  Option Name         Value Format   Contents",
  "  === (STR:Character-string, NUM:Numerical-valu, BOOL:Boolean) ===============",
  "  target_name                  STR   Hostname and port of dsnetm      (OPTION)",
  "  tty_mask                     NUM   Target TTYP I/O setting          (OPTION)",
  "  atty_mask                    NUM   IOP/EE TTYP Display setting      (OPTION)",
  "  file_priority                NUM   Priority of Remote File Access   (OPTION)",
  "  reset_on_start               BOOL  Whether to reset on starting     (OPTION)",
  "  check_manager_version        BOOL  Whether to check manager version (OPTION)",
  "  target_exec_ctl_config       NUM   Target execution control status",
  "  target_exec_ctl_override     NUM   Target execution control overwrite",
  "  dr_default_format            STR   Default format of dr command",
  "  dr_default_di                STR   di execution content at dr command",
  "  ex_default_dr                STR   dr execution content at exception ",
  "  dr0_default_di               STR   di execution content at dr -vu0",
  "  ex0_default_dr               STR   dr execution content at VU0 exception",
  "  dr1_default_di               STR   di execution content at dr -vu1 ",
  "  ex1_default_dr               STR   dr execution content at VU1 exception",
  "  lstep_default_list           STR   list execution content at lstep,lnext",
  "  lstep_stop_at_no_line        NUM   Wheter to stop at no line of lstep,lnext",
  "  source_directories           STR   Source directory list for di,list",
  "  initial_ebootp               STR   Initial value of boot parameter for EE",
  "  current_ebootp               STR   Current value of boot parameter for EE",
  "  initial_ibootp               STR   Initial value of boot parameter for IOP",
  "  current_ibootp               STR   Current value of boot parameter for IOP",
  "  automatic_prefix_breakpoint  BOOL  Automatic prefix to breakpoint number",
  "  describe_ub_all              BOOL  All deletion is allowed by only all for ub",
  "  di_address                   NUM   Address format of di command",
  "  di_instruction_word          NUM   Instruction word format of di command",
  "  di_branch_address            NUM   Branch address format of di command",
  "  di_macro                     NUM   Macro control for as,di command",
  "  help_lang                    STR   Language selection for help",
  "  help_pager                   STR   Pager selection for help",
  "  hex_radix                    BOOL  regarded as hex without 0x",
  "  log_total_size               NUM   Max total bytes of log",
  "  log_packet_size              NUM   Max bytes of log per packet",
  "  histfile                     STR   History save file name",
  "  histfilesize                 NUM   Number of histories to be saved",
  "  histsize                     NUM   Upper limit of histories",
  "  tty_max_size                 NUM   Number of max pending bytes in TTY packet",
  "",
  "  The dsidb examines the existence of \"~/.dsidbrc\" and \"./.dsidbrc\" on ",
  "  starting.  ",
  "  When these files exist, the debugger executes them as startup files on ",
  "  activation.",
  "",
  "  The options shown with (OPTION) in the above-mentioned options are ",
  "  the ones which can be set only by the definition of options in ",
  "  the startup file.  ",
  "  Since they are valid only after the program is started, they cannot ",
  "  be changed later. ",
  "  The argument of the option is the same as that of the set command. ",
  "-L1",
  "--j target_name",
  "  target_name                 文字列   dsnetm のホスト名およびポート   (OPTION)",
  "",
  "    dsnetm のホスト名およびポートは以下の 3 つの方法のいずれかで",
  "    設定できます。",
  "",
  "      1) 環境変数 \"DSNETM\" の値",
  "      2) 起動時の自動実行ファイル中の option 文",
  "      3) dsidb の起動オプションの -d <host>[:<port>]",
  "",
  "    複数が指定されている場合には 1)->2)->3) の順序で設定を上書きします。",
  "    このオプションのデフォルト値は \"\" (空の文字列)で、dsidb を実行した",
  "    同じホストのデフォルトポート指定の意味を持ちます。",
  "--e target_name",
  "  target_name                  STR   Hostname and port of dsnetm      (OPTION)",
  "",
  "    The hostname and port of the dsnetm can be set with one of ",
  "    the following 1), 2) and 3). ",
  "",
  "      1) Value of environment variable \"DSNETM\"",
  "      2) Option sentence in the startup file on activation",
  "      3) -d <host>[:<port>] of dsidb start option",
  "",
  "    When two or more are specified, the debugger overwrites ",
  "    the setting in the order of 1)->2)->3). ",
  "    The default value of this option is the \"\" (empty character string), ",
  "    and has the meaning of default port specification of the host ",
  "    which has performed the dsidb.",
  "--j tty_mask",
  "  tty_mask                    数値     ターゲットの TTYP 入出力の設定  (OPTION)",
  "",
  "    ターゲットの TTYP 入出力を dsidb で扱うかどうかの設定を行ないます。",
  "    dsidb でターゲットの TTYP 入出力を扱いたくない場合には 0 を指定します。",
  "    TTYP は E0TTYP から E9TTYP および EKTTYP の 11 個があり、",
  "    この tty_mask のビット 0 は E0TTYP に対応し、ビット 9 は E9TTYP に",
  "    対応します。EKTTYP の指定はビット 15 で行います。",
  "    Remote File Access サーバから送られてくるエラーメッセージの表示制御も",
  "    このオプションのビット 16 で行います。",
  "    (各ビットが on の時は dsidb で「扱う」、off の時は「扱わない」)",
  "    このオプションのデフォルト値は 0x83ff です。",
  "    なお dsidb の TTYP 出力は dsecons とは異なり LF による行単位の表示",
  "    のみをサポートします。",
  "--e tty_mask",
  "  tty_mask                     NUM   Target TTYP I/O setting          (OPTION)",
  "",
  "    Set wether if the taraget TTYP I/O be handled with the dsidb or not.  ",
  "    If you are not handling the taraget TTYP I/O with the dsidb, specify 0.",
  "    There are 11 types of TTYP from E0TTYP to E9TTYP or EKTTYP.  ",
  "    Bit 0 of the tty_mask corresponds to EOTTYP and Bit 9 corresponds to E9TTYP.",
  "    EKTTYP can be specified with Bit 15. ",
  "    Bit 16 of this option can be controlled error message from the Remote",
  "    File Access server.",
  "    The default value of this option is 0x183ff. ",
  "--j atty_mask",
  "  atty_mask                   数値     IOP/EE TTYP 表示の設定          (OPTION)",
  "",
  "    dsedb の場合は IOP の TTYP の、dsidb の場合は EE の TTYP の表示を行うか",
  "    どうかの設定を行います。ビット値の定義は tty_mask と同様です。",
  "    このオプションのデフォルト値は 0x0 です。",
  "--e atty_mask",
  "  atty_mask                    NUM   IOP/EE TTYP Display setting      (OPTION)",
  "",
  "    Set whether if the IOP TTYP be displayed or not for the dsedb.",
  "    Set whether if the EE TTYP be displayed or not for the dsidb.",
  "    The bit definitions is the same as that of tty_mask option.",
  "    The default value of this option is 0x0.",
  "--j file_priority",
  "  file_priority               数値     Remote File Access の優先順位   (OPTION)",
  "",
  "    ターゲットからの Remote File Access を dsidb で扱うかどうかの設定を",
  "    行ないます。dsidb でターゲットからの Remote File Access を",
  "    扱いたくない場合には -1 を指定します。",
  "    このオプションのデフォルト値は 0xd0 です。",
  "--e file_priority",
  "  file_priority                NUM   Priority of Remote File Access   (OPTION)",
  "",
  "    Set wether if the Remote File Access from the target be handled with ",
  "    the dsidb or not. If you are not handling the Remote File Access from",
  "    the target with the dsidb, specify -1. ",
  "    The default value of this option is 0xd0. ",
  "--j reset_on_start",
  "  reset_on_start              ブール   起動時のリセットの有無          (OPTION)",
  "",
  "    dsidb が起動時にターゲットをリセットするかどうかを指定します。",
  "    この指定はコマンドラインオプションの -r や -nr のどちらも指定されて",
  "    いない時に有効となります。このオプションのデフォルト値は true です。",
  "--e reset_on_start",
  "  reset_on_start               BOOL  Whether to reset on starting     (OPTION)",
  "",
  "    Specify whether or not the dsidb resets the target at boot time. ",
  "    This specification is valid when neither -r nor -nr of the command ",
  "    line options is specified.  The default value of this option is true. ",
  "--j check_manager_version",
  "  check_manager_version       ブール   manager version チェックの有無  (OPTION)",
  "",
  "    dsidb が起動時に dsnetm のバージョン情報をチェックするかどうかを",
  "    指定します。true ならチェックし、異なるならエラー終了します。",
  "    false ならバージョン情報はチェックしません。",
  "    このオプションのデフォルト値は false です。",
  "    コマンドラインで -cmv が指定されている場合には true に上書きされます。",
  "--e check_manager_version",
  "  check_manager_version        BOOL  Whether to check manager version (OPTION)",
  "",
  "    The dsidb specifies whether to check the version information on ",
  "    the dsnetm at boot time.  ",
  "    When true, checking is performed, and when not, the operation is ",
  "    terminated with an error.",
  "    When false, the version information is not checked.",
  "    The default value for this option is false.",
  "    If the -cmv is specified in the command line, it is overwritten by ",
  "    true.",
  "--j target_exec_ctl_config",
  "  target_exec_ctl_config      数値     ターゲット実行制御の状態",
  "",
  "    cont,step,next 等の実行コマンドの実行制御状態を示します。",
  "    0 の時はホスト側での制御、それ以外はターゲット側での制御を意味します。",
  "--e target_exec_ctl_config",
  "  target_exec_ctl_config       NUM   Target execution control status",
  "",
  "    This shows execution control state of an execution command such as ",
  "    cont, step, next, etc.",
  "    0 means the control on the host side.  Others mean control on the ",
  "    target side.",
  "--j target_exec_ctl_override",
  "  target_exec_ctl_override    数値     ターゲット実行制御の上書き",
  "",
  "    target_exec_ctl_config の値への上書き指定で、0 以上の値の時",
  "    上書きを行います。",
  "--e target_exec_ctl_override",
  "  target_exec_ctl_override     NUM   Target execution control overwrite",
  "",
  "    This specifies overwriting to the value of target_exec_ctl_config.  ",
  "    Overwriting is performed to the Value of 0 or more.",
  "--j dr_default_format",
  "  dr_default_format           文字列   dr コマンドのデフォルト表示形式指定",
  "",
  "    デフォルト値は option dr_default_format=\"\" であり、これは内部で",
  "    固定的に持っている表示形式を使用する事を意味します。これと等価な",
  "    明示的設定を行うには ~/.dsidbrc の場合には",
  "",
  "      option dr_default_format=\"\\",
  "       at=%at  v0-1=%v0,%v1  a0-3=%a0,%a1,%a2,%a3\\n\\",
  "       t0-7=%t0,%t1,%t2,%t3, %t4,%t5,%t6,%t7\\n\\",
  "       s0-7=%s0,%s1,%s2,%s3, %s4,%s5,%s6,%s7\\n\\",
  "       t8=%t8 t9=%t9   k0=%k0 k1=%k1   gp=%gp sp=%sp\\n\\",
  "       fp=%fp ra=%ra   lo=%lo hi=%lo   PC=%PC bada=%bada\\n\\",
  "       $cr=0x%cr [%symcr]\\n\\",
  "       $sr=0x%sr [%symsr]\\n\"",
  "",
  "    で、~/.dsedbrc の場合には",
  "",
  "      option dr_default_format=\"\\",
  "       at=%at  v0-1=%v0,%v1  a0-3=%a0,%a1,%a2,%a3\\n\\",
  "       t0-7=%t0,%t1,%t2,%t3, %t4,%t5,%t6,%t7\\n\\",
  "       s0-7=%s0,%s1,%s2,%s3, %s4,%s5,%s6,%s7\\n\\",
  "       t8=%t8 t9=%t9   k0=%k0 k1=%k1   gp=%gp sp=%sp\\n\\",
  "       fp=%fp ra=%ra   lo=%lo hi=%lo   sa=%sa PC=%PC\\n\\",
  "       badvaddr=%badvaddr badpaddr=%badpaddr\\n\\",
  "       $cause   = 0x%cause [%symcause]\\n\\",
  "       $status  = 0x%status [%symstatus]\\n\"",
  "",
  "    とします。",
  "",
  "    変換の対象となるものは以下に限られます。",
  "",
  "      %%          - '%' を意味する。",
  "",
  "      %<reg>      - レジスタ名 <reg> を printf(\"%08x\",...) で表示。",
  "",
  "    <reg> には以下のいずれも指定「できません」。",
  "",
  "       レジスタグループ名",
  "       $<n> の数値表現に対応するもの",
  "       疑似レジスタ名",
  "       '$' の前置",
  "       '_' の前置、",
  "       cr -> cause, sr -> status の別名 (dsedb)",
  "       cause -> cr の別名 (dsidb)",
  "",
  "    指定できない名前が指定された場合には %<reg> は変換せずに表示します。",
  "",
  "    cause,status レジスタのシンボリックな表示は上の例のように",
  "    dsidb の場合には %symcr,%symsr、dsedb の場合には %symstatus,%symcause",
  "    という指定が可能で、必ず前後に 1 つのスペースが表示されます。",
  "",
  "    また %08x 以外の 128bit レジスタや 16bit 表示は未サポートであり、",
  "    dsedb の dr -vu[01] の場合の設定オプションは存在しません。",
  "--e dr_default_format",
  "  dr_default_format            STR   Default format of dr command",
  "",
  "    The default value is \"\", it means to use built-in display format.",
  "    The followings are equivalent to the built-in display format.",
  "",
  "    ~/dsidbrc:",
  "",
  "      option dr_default_format=\"\\",
  "       at=%at  v0-1=%v0,%v1  a0-3=%a0,%a1,%a2,%a3\\n\\",
  "       t0-7=%t0,%t1,%t2,%t3, %t4,%t5,%t6,%t7\\n\\",
  "       s0-7=%s0,%s1,%s2,%s3, %s4,%s5,%s6,%s7\\n\\",
  "       t8=%t8 t9=%t9   k0=%k0 k1=%k1   gp=%gp sp=%sp\\n\\",
  "       fp=%fp ra=%ra   lo=%lo hi=%lo   PC=%PC bada=%bada\\n\\",
  "       $cr=0x%cr [%symcr]\\n\\",
  "       $sr=0x%sr [%symsr]\\n\"",
  "",
  "    ~/.dsedbrc:",
  "",
  "      option dr_default_format=\"\\",
  "       at=%at  v0-1=%v0,%v1  a0-3=%a0,%a1,%a2,%a3\\n\\",
  "       t0-7=%t0,%t1,%t2,%t3, %t4,%t5,%t6,%t7\\n\\",
  "       s0-7=%s0,%s1,%s2,%s3, %s4,%s5,%s6,%s7\\n\\",
  "       t8=%t8 t9=%t9   k0=%k0 k1=%k1   gp=%gp sp=%sp\\n\\",
  "       fp=%fp ra=%ra   lo=%lo hi=%lo   sa=%sa PC=%PC\\n\\",
  "       badvaddr=%badvaddr badpaddr=%badpaddr\\n\\",
  "       $cause   = 0x%cause [%symcause]\\n\\",
  "       $status  = 0x%status [%symstatus]\\n\"",
  "",
  "    The only following two cases are converted.",
  "",
  "      %%          - means '%' itself",
  "",
  "      %<reg>      - display register (<reg>) by printf(\"%08x\",...)",
  "",
  "    The followings are can not use as <reg>.",
  "",
  "       register group name",
  "       $<n>",
  "       pseudo register name",
  "       prefix of '$'",
  "       prefix of '_'",
  "       alias of cr -> cause, sr -> status (dsedb)",
  "       alias of cause -> cr (dsidb)",
  "",
  "    To symbolic display for cause,status registers, ",
  "    \"%symcr,%symsr\" (dsidb), and \"%symstatus,%symcause\" (dsedb) are valid.",
  "",
  "    The followings are unsupported.",
  "",
  "      display for 128bit register",
  "      display for 16bit register",
  "      option for dr -vu[01] (dsedb)",
  "--j dr_default_di",
  "  dr_default_di               文字列   dr コマンド時の di 実行内容指定",
  "",
  "    dr コマンドを引数なしで指定すると、現在の $PC の前後を逆アセンブル表示を",
  "    行いますが、その表示方法はこのオプションの値で決まります。",
  "    設定がない場合のデフォルト値は \"\\\\di -m $PC $_PC-8 7\" です。",
  "    (先頭の '\\' は alias 展開をしない、という指定です)",
  "--e dr_default_di",
  "  dr_default_di                STR   di execution content at dr command",
  "",
  "    When the dr command is specified without an argument, the debugger ",
  "    disassembles and displays the addresses before and after ",
  "    the $PC.  ",
  "    The method of display is decided by the value of this option. ",
  "    The default value when there is no setting is \"\\\\di -m $PC $_PC-8 7\".  ",
  "    (The first '\\' is a specification for not expanding the alias.)",
  "--j ex_default_di",
  "  ex_default_dr               文字列   例外発生時の dr 実行内容指定",
  "",
  "    cont、step、next 等で実行を開始しブレークポイントや例外発生によって",
  "    停止した場合に dr 表示を行ないますが、その表示方法はこのオプションの",
  "    値で決まります。設定がない場合のデフォルト値は \"\\\\dr\" です。",
  "--e ex_default_di",
  "  ex_default_dr                STR   dr execution content at exception ",
  "",
  "    When execution starts with cont, step, next, etc. and stops with ",
  "    a break point and generation of exception, the debugger performs dr ",
  "    display.  The method of displaying is decided by the value ",
  "    of this option.  The default value when there is no setting is \"\\\\dr\".",
  "--j dr0_default_di",
  "  dr0_default_di              文字列   dr -vu0 コマンド時の di 実行内容指定",
  "",
  "    dr -vu0 実行時の逆アセンブル表示方法の指定です。設定がない場合の",
  "    デフォルト値は \"\\\\vdi -vu0 -m $_vu0vi26 $_vu0vi26-3 7\" です。",
  "--e dr0_default_di",
  "  dr0_default_di               STR   di execution content at dr -vu0",
  "",
  "    This specifies the disassembly display method at the execution of ",
  "    dr -vu0.  The default value when there is no setting is     ",
  "     \"\\\\vdi -vu0 -m $_vu0vi26 $_vu0vi26-3 7\" .",
  "--j ex0_default_dr",
  "  ex0_default_dr              文字列   VU0 例外発生時の dr 実行内容指定",
  "",
  "    VU0 例外発生時の dr 表示方法の指定です。",
  "    設定がない場合のデフォルト値は \"\\\\dr -vu0\" です。",
  "--e ex0_default_dr",
  "  ex0_default_dr               STR   dr execution content at VU0 exception",
  "",
  "    This specifies the dr display method when a VU0 exception occurs.",
  "    The default value when there is no setting is \"\\\\dr -vu0\".",
  "--j dr1_default_di",
  "  dr1_default_di              文字列   dr -vu1 コマンド時の di 実行内容指定",
  "",
  "    dr -vu0 実行時の逆アセンブル表示方法の指定です。設定がない場合の",
  "    デフォルト値は \"\\\\vdi -vu1 -m $_vu1vi26 $_vu1vi26-3 7\" です。",
  "--e dr1_default_di",
  "  dr1_default_di               STR   di execution content at dr -vu1 ",
  "",
  "    This specifies the disassembly display method at the execution of ",
  "    dr-vu0.  The default value when there is no setting is ",
  "    \"\\\\vdi -vu1 -m $_vu1vi26 $_vu1vi26-3 7\" .",
  "--j ex1_default_di",
  "  ex1_default_dr              文字列   VU1 例外発生時の dr 実行内容指定",
  "",
  "    VU0 例外発生時の dr 表示方法の指定です。",
  "    設定がない場合のデフォルト値は \"\\\\dr -vu1\" です。",
  "--e ex1_default_di",
  "  ex1_default_dr               STR   dr execution content at VU1 exception",
  "",
  "    This specifies the dr display method when a VU1 exception is ",
  "    generated.  ",
  "    The default value when there is no setting is \"\\\\dr -vu1\".",
  "--j lstep_default_list",
  "  lstep_default_list          文字列   lstep,lnext 実行後の list 実行指定",
  "",
  "    lstep、lnext の正常終了時に実行するリスト表示方法を指定します。",
  "    設定がない場合のデフォルト値は \"\\\\list\" です。",
  "--e lstep_default_list",
  "  lstep_default_list           STR   list execution content at lstep,lnext",
  "",
  "    The list execution content by normal end of lstep or lnext,",
  "    The default is \"\\\\list\".",
  "--j lstep_stop_at_no_line",
  "  lstep_stop_at_no_line       数値     lstep,lnext で行番号がない場合に停止",
  "",
  "    lstep、lnext の開始時または実行中の $PC が行番号を持たない場所であった",
  "    場合にコマンドを終了させるかどうかの指定です。",
  "      0 の時: 行番号を持つ場所まで内部で step,next 動作を続けます。",
  "      1 の時: その旨を表示し、コマンドを終了します。(デフォルト)",
  "--e lstep_stop_at_no_line",
  "  lstep_stop_at_no_line        NUM   Wheter to stop at no line of lstep,lnext",
  "",
  "    Wheter to stop at no line information at starting or after internal",
  "    step/next.",
  "      0: Until location which has line information, continue internal",
  "         step/next execution.",
  "      1: Display the reason, and finish the command. [default]",
  "--j source_directories",
  "  source_directories          文字列   ソース探索ディレクトリリストの指定",
  "",
  "    di および list コマンドで参照されるソースファイルの探索ディレクトリを",
  "    指定します。",
  "",
  "    実行ファイルの .mdebug 中に含まれるソースファイル名の先頭が '/'",
  "    (絶対パス) である場合や、source_directories 変数が \"\" である場合には",
  "    ソースファイル名そのままのみを参照します。",
  "",
  "    それ以外の場合には、単独または複数(区切りは ':')のディレクトリ名を",
  "    ソースファイル名に前置して参照を試みます。なお空の区切りは空の前置を",
  "    意味します。例えば \".:\" は \".\" の次に \"\" の前置となります。",
  "",
  "    指定ディレクトリ名が '@' で始まる場合には '@' 部分をオブジェクト",
  "    ファイル名の絶対パスに変換されたディレクトリ名で置換します。",
  "",
  "    このオプションのデフォルト値は \"\" です。",
  "",
  "      オブジェクトのあるディレクトリのみの場合の指定例)",
  "          set source_directories=\"@\"",
  "",
  "      カレントディレクトリ -> オブジェクト位置 -> ABC -> DEF の順の指定例)",
  "          set source_directories=\".:@:ABC:DEF\"",
  "--e source_directories",
  "  source_directories           STR   Source directory list for di,list",
  "",
  "    Source directory search list for di and list commands.",
  "",
  "    If the top character of source file name is '/' (absolute path),",
  "    or source_directories option value is \"\" (empty), di and list commands",
  "    refer to the only original source file name.",
  "",
  "    Otherwise, the specified search list is used. The search list is directory",
  "    names delimitted by ':'. ",
  "",
  "    '@' for the starting character of directory name has special meanings.",
  "    '@' is replaced by directory name of object file name which is converted",
  "    to absolute path.",
  "",
  "    The default value of source_directories is \"\".",
  "",
  "      Example 1) only same directory of object file",
  "                   set source_directories=\"@\"",
  "",
  "      Example 2) current directory -> object directory -> ABC -> DEF",
  "                   set source_directories=\".:@:ABC:DEF\"",
  "--j initial_ebootp current_ebootp initial_ibootp current_ibootp",
  "  initial_ebootp              文字列   EE 用ブートパラメータの初期値",
  "  current_ebootp              文字列   EE 用ブートパラメータの現在値",
  "  initial_ibootp              文字列   IOP 用ブートパラメータの初期値",
  "  current_ibootp              文字列   IOP 用ブートパラメータの現在値",
  "",
  "    reset コマンドで参照されるブートパラメータ値です。",
  "    それぞれの意味については reset コマンドの説明部分を参照して下さい。",
  "    initial_ebootp のデフォルト値は \"-1\"、",
  "    current_ebootp のデフォルト値は \"-1\"、",
  "    initial_ibootp のデフォルト値は \"-1\"、",
  "    current_ibootp のデフォルト値は \"-1\" です。",
  "    (\"-1\" は現在の値を変更しない、という意味を持ちます)",
  "--e initial_ebootp current_ebootp initial_ibootp current_ibootp",
  "  initial_ebootp               STR   Initial value of boot parameter for EE",
  "  current_ebootp               STR   Current value of boot parameter for EE",
  "  initial_ibootp               STR   Initial value of boot parameter for IOP",
  "  current_ibootp               STR   Current value of boot parameter for IOP",
  "",
  "   The following are the boot parameter values referred to with reset ",
  "   command.",
  "   For each of the meanings below, refer to the description part of ",
  "   the reset command.",
  "",
  "    The default value of initial_ebootp is \"-1\".",
  "    The default value of current_ebootp is \"-1\".",
  "    The default value of initial_ibootp is \"-1\".",
  "    The default value of current_ibootp is \"-1\".",
  "    (\"-1\" means that the current value is not changed.)",
  "--j automatic_prefix_breakpoint",
  "  automatic_prefix_breakpoint ブール   ブレークポイント番号形式への自動前置",
  "",
  "    ub,be,bd コマンドの引数はアドレスですが、そのアドレス指定中の",
  "    表現式中には $BP<n> の形式の疑似レジスタを指定できます。",
  "    この automatic_prefix_breakpoint 変数が true の場合、",
  "    ub,be,bd コマンドの引数がすべて 10 進数での数値のみで構成されている場合に",
  "    自動的に \"$BP\" を指定引数に前置します。",
  "    デフォルト値は false です。",
  "--e automatic_prefix_breakpoint",
  "  automatic_prefix_breakpoint  BOOL  Automatic prefix to breakpoint number",
  "",
  "    The argument of the ub, be and bd command is the address.  In ",
  "    the expression specifying the address, a pseudo register in ",
  "    the $BP<n> format can be specified.",
  "    If the automatic_prefix_breakpoint variable is true, the \"$BP\" is ",
  "    automatically placed in front of the \"$BP\" when all the arguments of ",
  "    the ub, be and db commands are composed of numerical values in ",
  "    decimal number only.   ",
  "    The default value is false.",
  "--j describe_ub_all",
  "  describe_ub_all             ブール   ub で all 指定時のみに全削除を行う",
  "",
  "    ub コマンドでは引数を省略した場合全てのブレークポイントを削除の指定に",
  "    なりますが、describe_ub_all 変数が true の場合には全削除は禁止されます。",
  "    デフォルト値は false です。",
  "--e describe_ub_all",
  "  describe_ub_all              BOOL  All deletion is allowed by only all for ub",
  "",
  "    When argument is omitted for ub commands, all break point is deleted",
  "    in ub command. If the describe_ub_all variable is true, all deletion is",
  "    not allowed when argument is omitted.",
  "    The default value is false.",
  "--j di_address",
  "  di_address                  数値     di コマンドのアドレス表示方式",
  "",
  "    di コマンドのアドレス(ラベル)部分の表示方式指定です。",
  "      0x0 の時: 16 進数とシンボルの両方を表示します。",
  "      0x1 の時: 16 進数のみで表示します。",
  "      0x2 の時: シンボルが存在するならシンボルのみ、それ以外は 16 進数。",
  "      0x3 の時: 同じシンボルに関して一度だけ独立した行で表示します。",
  "      0x4 の時: 0x0 の時に加えて行番号も表示します。",
  "      0x5 の時: 0x1 の時に加えて行番号も表示します。",
  "      0x6 の時: 0x2 の時に加えて行番号も表示します。",
  "      0x7 の時: 0x3 の時に加えて行番号も表示します。",
  "      0x8 の時: 0x4 の時に加えてソース行も表示します。",
  "      0x9 の時: 0x5 の時に加えてソース行も表示します。",
  "      0xa の時: 0x6 の時に加えてソース行も表示します。",
  "      0xb の時: 0x3 の時に加えてソース行も表示します。ソースファイルが",
  "                アクセスできない場合には 0x7 の時と同一です。(デフォルト)",
  "",
  "    行番号やソース行を表示するには gcc -g で実行ファイルを作成して下さい。",
  "--e di_address",
  "  di_address                   NUM   Address format of di command",
  "",
  "    Address (label) format of di command.",
  "      0x0: Hex. number and symbol",
  "      0x1: Only hex. number",
  "      0x2: If symbol is exist then only symbol, else Hex. number",
  "      0x3: Display once for same symbol by independent line",
  "      0x4: 0: + line number",
  "      0x5: 1: + line number",
  "      0x6: 2: + line number",
  "      0x7: 3: + line number",
  "      0x8: 4: + source line",
  "      0x9: 5: + source line",
  "      0xa: 6: + source line",
  "      0xb: 3: + source line if debugger can access to the source file.",
  "           otherwise same to 0x7.  [default]",
  "",
  "    To display line number or source line, use \"gcc -g\".",
  "--j di_instruction_word",
  "  di_instruction_word         数値     di コマンドの命令ワードの表示方式",
  "",
  "    di コマンドの命令ワード部分の表示方式指定です。",
  "      0 の時: 命令ワードを 16 進数表示を行います。(デフォルト)",
  "      1 の時: 命令ワードの 16 進数表示は行いません。",
  "--e di_instruction_word",
  "  di_instruction_word          NUM   Instruction word format of di command",
  "",
  "    Instruction word format of di command.",
  "      0: Display by hex. number [default]",
  "      1: Not display instruction word",
  "--j di_branch_address",
  "  di_branch_address           数値     di コマンドの分岐アドレス表示方式",
  "",
  "    di コマンドの分岐アドレス部分の表示方式指定です。",
  "      0 の時: 16 進数とシンボルの両方を表示します。(デフォルト)",
  "      1 の時: 16 進数のみで表示します。",
  "      2 の時: シンボルが存在するならシンボルのみ、それ以外は 16 進数で",
  "              表示します。",
  "--e di_branch_address",
  "  di_branch_address            NUM   Branch address format of di command",
  "",
  "    Branch address format of di command",
  "      0: Hex. number and symbol [default]",
  "      1: Only hex. number",
  "      2: If symbol is exist then only symbol, else Hex. number",
  "--j di_macro",
  "  di_macro                    数値     di/as コマンドのマクロ命令制御",
  "",
  "    di/as コマンドで li,move 等のマクロ命令を扱うかどうかを指定します。",
  "      0 の時: マクロ命令は扱いません。",
  "      1 の時: li,move,b,bal,dmove のマクロ命令を扱います。(デフォルト)",
  "--e di_macro",
  "  di_macro                     NUM   Macro control for as,di command",
  "",
  "    Macro instruction control for as,di command.",
  "      0: No macro instruction",
  "      1: Using macro instructions (li,move,b,bal,dmove) [default]",
  "--j help_lang",
  "  help_lang                   文字列   ヘルプ表示の言語",
  "",
  "    help コマンドで表示する言語を指定します。",
  "      \"eng\" : 英語 (デフォルト)",
  "      \"euc\" : 日本語 (EUC コード)",
  "      \"jis\" : 日本語 (JIS コード)",
  "      \"sjis\": 日本語 (シフトJIS コード)",
  "--e help_lang",
  "  help_lang                    STR   Language selection for help",
  "",
  "    Specify language for help.",
  "      \"eng\" : English [default]",
  "      \"euc\" : Japanese (EUC code)",
  "      \"jis\" : Japanese (JIS code)",
  "      \"sjis\": Japanese (Shift-JIS code)",
  "--j help_pager",
  "  help_pager                  文字列   ヘルプ表示に使用するページャ",
  "",
  "    help コマンドで表示するページャを指定します。",
  "    デフォルトは \"\" (空の文字列) でページャは使用しません。",
  "--e help_pager",
  "  help_pager                   STR   Pager selection for help",
  "",
  "    Specify pager for help.",
  "    Default is \"\" (empty string), it means using no pager",
  "--j hex_radix",
  "  hex_radix                   ブール   数値を 0x なしで 16 進数とみなす",
  "",
  "    dsidb の数値指定の解釈の方法を設定します。",
  "    デフォルト値は true で、数値は 0x なしで 16 進数と解釈されます。",
  "    false の場合は C 言語と同じく 16 進数は 0x を前置しなければなりません。",
  "    シンボルがなければ true の方が便利ですが、シンボルがあり例えば",
  "    db abc のように指定された場合に、abc というシンボルもあると",
  "    db 0xabc と入力し直す必要があり、あいまいさが残ります。",
  "    false の場合には db abc は常にシンボルのみをサーチするため、",
  "    このような「場合によっては入力しなおす」必要は生じません。",
  "--e hex_radix",
  "  hex_radix                    BOOL  regarded as hex without 0x",
  "",
  "    This sets the method of interpreting numeric specification of dsidb.  ",
  "    The default value is true, and the numerical value is interpreted ",
  "    as the hex number without 0x.  ",
  "    In the case of false, 0x should be put in front of the value as is ",
  "    the case in C.",
  "    ",
  "    The true is more convenient than the false if there is no symbol.  ",
  "    However, if there is a symbol and is specified, for example, as ",
  "    \"db abc\", when there is also a symbol \"abc\", the value should be ",
  "    input again as \"db 0xabc\", and ambiguity remains.  ",
  "    In the case of false, \"db abc\" always searches only for the symbol, ",
  "    it is unnecessary to \"input the value again as occasion demands\" ",
  "    unlike the above-mentioned case. ",
  "--j log_total_size",
  "  log_total_size              数値     送受信ログの最大合計バイト数",
  "",
  "    デフォルトでは合計バイト数が 128KB まで DECI2 パケットのログを",
  "    保存します。送受信ログが不要の場合には 0 を設定して下さい。",
  "--e log_total_size",
  "  log_total_size               NUM   Max total bytes of log",
  "",
  "    The debugger stores the log of the DECI2 packet up to the total bytes ",
  "    of 128KB at the default.  Set 0 when the transmitting/receiving log ",
  "    is unnecessary. ",
  "--j log_packet_size",
  "  log_packet_size             数値     送受信ログのパケットごとの最大バイト数",
  "",
  "    デフォルトではパケットの先頭から 128 バイトまでのデータを",
  "    ログに保存します。すべてのデータをログに保存したい場合には",
  "    65535 以上の値を設定して下さい。",
  "--e log_packet_size",
  "  log_packet_size              NUM   Max bytes of log per packet",
  "",
  "    The debugger stores the data from the head of the packet to 128 bytes ",
  "    in the log at the default.  Set the value of 65535 or more to store ",
  "    all the data in the log. ",
  "--j histfile",
  "  histfile                    文字列   ヒストリセーブファイル名",
  "",
  "    デフォルトでは \"~/.dsidb_history\" で、この文字列が示すファイルへ",
  "    dsidb の終了時にヒストリをセーブし、起動時にそのファイルからヒストリを",
  "    ロードします。",
  "--e histfile",
  "  histfile                     STR   History save file name",
  "",
  "    At the default, history is saved in the file indicated by ",
  "    the character string in process with \"~/.dsidb_history\" when dsidb ",
  "    is finished.  The history is loaded from this file on startup.",
  "--j histfilesize",
  "",
  "    histfile へセーブするヒストリ数です。デフォルト値は 256 です。",
  "--e histfilesize",
  "  histfilesize                 NUM   Number of histories to be saved",
  "",
  "    This is the number of histories to be saved in the histfile.  ",
  "    The default value is 256.",
  "--j histsize",
  "  histsize                    数値     ヒストリの上限数",
  "",
  "    コマンド操作中に記憶するヒストリ数の上限数です。デフォルト値は 256 です。",
  "--e histsize",
  "  histsize                     NUM   Upper limit of histories",
  "",
  "    This shows the upper limit of the number of histories to be stored ",
  "    in the process of operating a command.  The default value is 256.",
  "--j tty_max_size",
  "  tty_max_size                数値     TTY パケットの最大保留バイト数",
  "",
  "    dsidb が送信する TTY パケットの最大保留バイト数で、デフォルト値は",
  "    8MB です。",
  "--e tty_max_size",
  "  tty_max_size                 NUM   Number of max pending bytes in TTY packet",
  "",
  "    This shows the number of max pending bytes of the TTY packet",
  "    the dsidb transfers.  The default value is 8MB.",
  "-L0",
  "--j misc",
  " edit                        入力時の編集キー",
  " expr expression val value   表現式",
  " reg                         レジスタグループ",
  " keyword                     ヘルプキーワード",
  "--e misc",
  " edit                        edit key for input",
  " expr expression val value   expression",
  " reg                         register group",
  " keyword                     keyword for help",
  "-L1",
  "--j edit",
  "  コマンド入力時には矢印キーの他に以下の編集キーが使えます。",
  "",
  "  編集キー    機能",
  "  ==========================",
  "  CTRL-P      前の行への移動",
  "  CTRL-N      次の行への移動",
  "  CTRL-B      前の文字(左)への移動",
  "  CTRL-F      次の文字(右)への移動",
  "  CTRL-A      カレント行の先頭への移動",
  "  CTRL-E      カレント行の最後への移動",
  "  BS, DEL     前の文字の削除",
  "  CTRL-D      カレント文字の削除",
  "  CTRL-X      カレント行すべての削除",
  "  CTRL-U      カレント行すべての削除",
  "  CTRL-K      カレント行のカレント文字から行末までの削除",
  "  CTRL-L      カレント行の再表示",
  "  CTRL-C      入力の中断 (^C のエコーあり)",
  "  CTRL-G      入力の中断 (^G のエコーなし)",
  "  LF, CR      入力の終了、カレント行をコマンドとして実行",
  "  TAB         コマンド名、ファイル名、シンボル名などの補完",
  "  CTRL-R      逆方向サーチ",
  "  CTRL-S      順方向サーチ",
  "  CTRL-Y      CTRL-K で削除した文字列の挿入",
  "",
  "  TAB による補完は行の最後で TAB を入力した場合にのみ可能で、",
  "  以下の 4 つのケースをサポートしています。",
  "",
  "    1) 空白を含まない文字列",
  "         コマンド名として補完を試みます。",
  "",
  "    2) set コマンドの引数",
  "         オプション名として補完を試みます。",
  "",
  "    3) help コマンドの引数",
  "         ヘルプのキーワードとして補完を試みます。",
  "",
  "    4) その他のコマンドの引数",
  "         '/' もしくは '.' が含まれていた時はファイル名として",
  "         それ以外はシンボルとして補完を試みます。",
  "",
  "  プログラム実行時には、CTRL-C で break コマンドをターゲットに送ります。",
  "  CTRL-G では、break コマンドを送らないで単に dsidb に制御が戻ります。",
  "  RETURN キーで、メモリ内容の表示やステップ実行など、直前に実行したコマンド",
  "  を再実行できます。このとき、メモリの表示などはアドレスを増加させたうえ",
  "  で再実行されます。",
  "--e edit",
  "  The following edit keys are available besides the arrow keys when a ",
  "  command is input.",
  "",
  "  Edit Key   Function",
  "  ==========================",
  "  CTRL-P      Move to previous line",
  "  CTRL-N      Move to next line",
  "  CTRL-B      Move to previous (left) character",
  "  CTRL-F      Move to next (right) character",
  "  CTRL-A      Move to head of current line",
  "  CTRL-E      Move to end of current line",
  "  BS, DEL     Deletion of previous character",
  "  CTRL-D      Deletion of current character",
  "  CTRL-X      Deletion of whole current line",
  "  CTRL-U      Deletion of whole current line",
  "  CTRL-K      Deletion from current character of current line ",
  "              to end of line",
  "  CTRL-L      Re-display of current line",
  "  CTRL-C      Interrupt of input (with echo of ^C) ",
  "  CTRL-G      Interrupt of input (without echo of ^G) ",
  "  LF, CR      End of input and execution of program with ",
  "              the current line as a command ",
  "  TAB         Completion of command name, file name, symbol name, ...etc",
  "  CTRL-R      Search in reverse direction",
  "  CTRL-S      Search in forward direction",
  "  CTRL-Y      Insertion of a character string deleted with CTRL-K",
  "",
  "  The completion with the TAB is applicable only when the key is pressed",
  "  at the end of the line.  It supports the following four cases.",
  "",
  "    1) Character strings with no spaces",
  "         -> As command name.",
  "",
  "    2) Argument of set command",
  "         -> As option name for set command.",
  "",
  "    3) Argument of help command",
  "         -> As keyword for help command.",
  "",
  "    4) Others",
  "         -> If include '/' or '.', as a filename; if not, as symbol.",
  "",
  "  The debugger sends the break command to the target with CTRL-C at ",
  "  program execution.  With CTRL-G, the control only returns to the dsidb ",
  "  without sending the break command.  The commands for memory content ",
  "  display, stepwise execution, etc. executed immediately before can be ",
  "  re-executed with the RETURN key.  At this time, memory display etc. ",
  "  are re-executed after incrementing the address. ",
  "--j expr expression val value",
  "  ファイル名以外の一般的な値を持つコマンド引数には、以下の表現式（expr）を",
  "  使用することができます。",
  "",
  "      16 進数           # 0x はシンボルと重複しない限り省略可能",
  "      symbol            # シンボル",
  "      <fname>:<lineno>  # 行番号による指定",
  "      <fname>:<func>    # static で重複する名前の関数",
  "      .                 # 現在のアドレス (ドットアドレス)",
  "      .<digit>          # C 言語と同じ形式での数値 (8,10,16 進数)",
  "      $<reg>            # 現在のレジスタ値またはユーザ変数値",
  "      (expr)            # 式としての括弧",
  "      +expr             # 正の符号の明示",
  "      -expr             # 符号反転",
  "      ~expr             # ビット反転",
  "      *expr             # アドレス間接指定 (アドレスが指す先は常にワード)",
  "      expr1[expr2]      # *(expr1 + ((expr2) << 2)) と等価",
  "      expr1[expr2,b]    # expr1 + ((expr2) << 0) のアドレス間接 (byte)",
  "      expr1[expr2,h]    # expr1 + ((expr2) << 1) のアドレス間接 (half)",
  "      expr1[expr2,w]    # expr1 + ((expr2) << 2) のアドレス間接 (word)",
  "      expr1[expr2,d]    # expr1 + ((expr2) << 3) のアドレス間接 (double)",
  "      expr1[expr2,q]    # expr1 + ((expr2) << 4) のアドレス間接 (quad)",
  "      expr1[expr2,expr3]# アドレス間接指定 (expr3 はバイト数)",
  "      !expr             # 論理反転",
  "      expr1 || expr2    # 論理 OR",
  "      expr1 && expr2    # 論理 AND",
  "      expr1 |  expr2    # ビット OR",
  "      expr1 ^  expr2    # ビット XOR",
  "      expr1 &  expr2    # ビット AND",
  "      expr1 == expr2    # 等しい場合に真(=1)、それ以外は偽(=0)",
  "      expr1 != expr2    # 等しくない場合に真(=1)、それ以外は偽(=0)",
  "      expr1 <  expr2    # 符号なし比較 (less than)",
  "      expr1 <= expr2    # 符号なし比較 (less than or equal)",
  "      expr1 >  expr2    # 符号なし比較 (greater than)",
  "      expr1 >= expr2    # 符号なし比較 (greater than or equal)",
  "      expr1 >> expr2    # expr1 を右へ expr2ビットシフト(両方とも符号なし)",
  "      expr1 << expr2    # expr1 を左へ expr2ビットシフト(両方とも符号なし）",
  "      expr1 +  expr2    # expr1,expr2 の算術的加算(両方とも符号付なし)",
  "      expr1 -  expr2    # expr1,expr2 の算術的減算(両方とも符号付なし)",
  "      expr1 *  expr2    # expr1,expr2 の算術的乗算(両方とも符号付なし)",
  "      expr1 /  expr2    # expr1,expr2 の算術的除算(両方とも符号付なし)",
  "      expr1 %  expr2    # expr1,expr2 の算術的剰余(両方とも符号付なし)",
  "",
  "  括弧、単項演算子および二項演算子の優先順位は C 言語と同じであり、",
  "  以下のようになっています。",
  "",
  "        () []                           高い",
  "        ! + - ~ *       (単項演算子)",
  "        * / %",
  "        + -             (二項演算子)",
  "        << >>",
  "        < <= > >=",
  "        == !=",
  "        &",
  "        ^",
  "        |",
  "        &&",
  "        ||                              低い",
  "",
  "  表現式 (expr) 中の数値は特に指定がない限り 16 進として解釈します。",
  "  例外は $10 の '10' や、シンボル中の行番号などです。",
  "",
  "  16 進数の定義は [0[xX]][0-9a-fA-F]+ であり、大文字と小文字の区別は",
  "  ありません。16進数が使える箇所で10進数を指定するには、数字の前に'.'を",
  "  置いてください。8進数を指定するには'.0'を前置します。",
  "  '.'と数字の間に空白を空けることはできません。",
  "",
  "  シンボルの指定形式は以下のいずれかです。",
  "",
  "        a) <symbol>",
  "        b) :<symbol>",
  "",
  "  'a123' のように 16 進数としてもシンボルとしても解釈可能でそのシンボルが",
  "  実際に存在する場合にはエラーとしています。このような場合には、",
  "  16 進なら '0x'を前置し、シンボルならば ':a123' と ':' を前置し、どちらで",
  "  あるかを明示してください。",
  "",
  "  レジスタ名には '$a0'のようにシンボリックな表現の他に '$4'のような",
  "  番号指定も使えます。レジスタ番号指定時の数値部分は 10 進数です。",
  "",
  "  表現式中の \".\" は特殊なシンボルで、メモリの表示や設定、di、as 等の",
  "  各コマンド実行中は「現在のアドレス」の値を持ち、コマンド終了時には",
  "  「次のアドレス」の値となります。",
  "",
  "  以下は表現式の指定例です。",
  "",
  "        db 80100000",
  "        di main+0x100",
  "        di (main + 100 + *(1002 + 4) * 5)",
  "        di $epc-8",
  "        db $t0+0x124+$v0+buf",
  "--e expr expression val value",
  "  The following expressions (expr) can be used for the command ",
  "  arguments with general values other than the file name.",
  "",
  "      Hex. number       # 0x is omissible unless it overlaps with the symbol ",
  "      symbol            # Symbol",
  "      <fname>:<lineno>  # Specification by line number",
  "      <fname>:<func>    # static and duplicated name function",
  "      .                 # Present address (dot address)",
  "      .<digit>          # Numerical values in the same format as C ",
  "                          (octal/decimal/hex)",
  "      $<reg>            # Current register value or user variable value",
  "      (expr)            # Parentheses as expression",
  "      +expr             # Specification of positive sign",
  "      -expr             # Invert sign",
  "      ~expr             # Bit reversing",
  "      *expr             # Indirect address spec. (always point to word)",
  "      expr1[expr2]      # Equivalent to *(expr1 + ((expr2) << 2))",
  "      expr1[expr2,b]    # Indirect for (expr1 + ((expr2) << 0)) to byte",
  "      expr1[expr2,h]    # Indirect for (expr1 + ((expr2) << 1)) to half",
  "      expr1[expr2,w]    # Indirect for (expr1 + ((expr2) << 2)) to word",
  "      expr1[expr2,d]    # Indirect for (expr1 + ((expr2) << 3)) to double",
  "      expr1[expr2,q]    # Indirect for (expr1 + ((expr2) << 4)) to quad",
  "      expr1[expr2,expr3]# Indirect address spec. (expr3 is the number of bytes)",
  "      !expr             # Logical invert",
  "      expr1 || expr2    # Logical OR",
  "      expr1 && expr2    # Logical AND",
  "      expr1 |  expr2    # Bit OR",
  "      expr1 ^  expr2    # Bit XOR",
  "      expr1 &  expr2    # Bit AND",
  "      expr1 == expr2    # True(=1) if equal, otherwise False(=0)",
  "      expr1 != expr2    # True(=1) if not equal, otherwise False(=0)",
  "      expr1 <  expr2    # Unsigned compare (less than)",
  "      expr1 <= expr2    # Unsigned compare (less than or equal)",
  "      expr1 >  expr2    # Unsigned compare (greater than)",
  "      expr1 >= expr2    # Unsigned compare (greater than or equal)",
  "      expr1 >> expr2    # Shift of expr1 for expr2 bits to the right ",
  "                          (both unsigned)",
  "      expr1 << expr2    # Shift of expr1 for expr2 bits to the left ",
  "                          (both unsigned) ",
  "      expr1 +  expr2    # Arithmetic addition of expr1 and expr2 ",
  "                          (both unsigned)",
  "      expr1 -  expr2    # Arithmetic subtraction of expr2 from expr1 ",
  "                          (both unsigned)",
  "      expr1 *  expr2    # Arithmetic multiplication of expr1 and expr2 ",
  "                          (both unsigned)",
  "      expr1 /  expr2    # Arithmetic division of expr1 by expr2 ",
  "                          (both unsigned)",
  "      expr1 %  expr2    # Arithmetic surplus from division of expr1 ",
  "                          by expr2 (both unsigned)",
  "",
  "  The priority given to the parentheses, unary operator and dyadic ",
  "  operator is the same as that of C as shown below.",
  "",
  "        () []                         High",
  "        ! + - ~ *       (Unary operator)",
  "        * / %",
  "        + -             (Dyadic operator)",
  "        << >>",
  "        < <= > >=",
  "        == !=",
  "        &",
  "        ^",
  "        |",
  "        &&",
  "        ||                             Low",
  "",
  "  The debugger interprets the numerical value in the expression (expr) ",
  "  as a hexadecimal number unless otherwise specified.",
  "  The exceptions are '10' of $10, line number within a symbol, etc.",
  "",
  "  The definition of the hexadecimal number is [0[xX]] [0-9a-fA-F]+, and ",
  "  is case-independent.   ",
  "  To specify the decimal number in the part where the hexadecimal number ",
  "  can be used, place '.' in front of the number.  To specify the octal ",
  "  number, place '.0' in front of the number. ",
  "  No space can be made between the '.' and number.",
  "",
  "",
  "  The format to specify the symbol is one of the following. ",
  "",
  "        a) <symbol>",
  "        b) :<symbol>",
  "",
  "  If an expression, which can be interpreted both as a hex number and ",
  "  a symbol such as 'a123', actually exists, it is treated as an error.  ",
  "  In such a case, specify hex or symbol by putting '0x' in front of ",
  "  the hex number and put ':' in front of the symbol like ':a123'.",
  "  ",
  "  The number specification such as '$4' can be used besides the symbolic ",
  "  expression such as '$a0' for the register name.  The numeric part when ",
  "  the register number is specified is a decimal number. ",
  "  ",
  "  The \".\" in the expression is a special symbol.  It has the value of ",
  "  \"present address\" while a command such as memory display/setting, di ",
  "  or as is being executed, and becomes the value of the \"next address ",
  "  when the command ends. ",
  "",
  "  The following are examples of specifying expressions. ",
  "",
  "        db 80100000",
  "        di main+0x100",
  "        di (main + 100 + *(1002 + 4) * 5)",
  "        di $epc-8",
  "        db $t0+0x124+$v0+buf",
  "-Ej reg",
  "    レジスタグループ名  内容",
  "    all                 All registers",
  "    gpr                 General Purpose Registers",
  "    hls                 HI、LO、HI1、LO1、SA",
  "    scr                 System Coprocessor Registers",
  "    pcr                 Performance Counter Registers",
  "    hdr                 Hardware Breakpoint Registers",
  "    fpr                 Floating Point Registers",
  "    fpc                 Floating Point Control Registers",
  "    vu0f                VU0 Floating Registers",
  "    vu0i                VU0 Integer Registers",
  "    vu1f                VU1 Floating Registers",
  "    vu1i                VU1 Integer Registers",
  "-Ee reg",
  "    Register Group Name   Description",
  "    all                   All registers",
  "    gpr                   General Purpose Registers",
  "    hls                   HI,LO,HI1,LO1,SA",
  "    scr                   System Coprocessor Registers",
  "    pcr                   Performance Counter Registers",
  "    hdr                   Hardware Breakpoint Registers",
  "    fpr                   Floating Point Registers",
  "    fpc                   Floating Point Control Registers",
  "    vu0f                  VU0 Floating Registers",
  "    vu0i                  VU0 Integer Registers",
  "    vu1f                  VU1 Floating Registers",
  "    vu1i                  VU1 Integer Registers",
  "-Ij reg",
  "    レジスタグループ名  内容",
  "    all                 All registers",
  "    gpr                 General Purpose Registers",
  "    hl                  HI、LO",
  "    scc                 System Coprocessor Registers",
  "    c2r                 Coprocessor 2 (GTE) registers",
  "    c2c                 Coprocessor 2 (GTE) control registers",
  "    gte                 All GTE registers (cop2,cp2)",
  "-Ie reg",
  "    Register Group Name   Contents",
  "    all                   All registers",
  "    gpr                   General Purpose Registers",
  "    hl                    HI,LO",
  "    scc                   System Coprocessor Registers",
  "    c2r                   Coprocessor 2 (GTE) registers",
  "    c2c                   Coprocessor 2 (GTE) control registers",
  "    gte                   All GTE registers (cop2,cp2)",
  NULL
};

struct {HELP_MAP *head;HELP_MAP *tail;} help_maps = { NULL, NULL };
int current_col = 0;

static int first_18 = 0;

static void __cdecl print_char(void *stream, int ch);
static void __cdecl print_str(void *stream, char *str);
static void __cdecl print_nl(void *stream);
static void __cdecl print_jis(void *stream, char *s);
static void __cdecl print_sjis(void *stream, char *s);
static int __cdecl add_help_map(int ej, int level, char *key, char **pl);
static void __cdecl build_help_map(int lang);
static int __cdecl valid_delim(int lang, char *p);
static int __cdecl valid_lang(int lang, HELP_MAP *hm);

static void __cdecl print_char(void *stream, int ch)
{
  char s[1]; // [esp+3h] [ebp-1h] BYREF

  if ( stream )
  {
    s[0] = ch;
    ds_fwrite(s, 1, 1, stream);
  }
  else
  {
    ds_printf("%c", ch);
  }
  ++current_col;
}

static void __cdecl print_str(void *stream, char *str)
{
  int n; // [esp+0h] [ebp-4h]

  n = strlen(str);
  if ( stream )
    ds_fwrite(str, n, 1, stream);
  else
    ds_printf("%s", str);
  current_col += n;
}

static void __cdecl print_nl(void *stream)
{
  char s[1]; // [esp+3h] [ebp-1h] BYREF

  s[0] = 10;
  if ( stream )
    ds_fwrite(s, 1, 1, stream);
  else
    ds_printf("%c", s[0]);
  current_col = 0;
}

static void __cdecl print_jis(void *stream, char *s)
{
  int v2; // eax
  int v3; // eax
  int v4; // [esp-4h] [ebp-10h]
  int c1; // [esp+0h] [ebp-Ch]
  int c0; // [esp+4h] [ebp-8h]
  int ki; // [esp+8h] [ebp-4h]
#ifdef DSNET_COMPILING_E
  _DWORD *savedregs; // [esp+Ch] [ebp+0h] BYREF

  savedregs = &savedregs;
#endif /* DSNET_COMPILING_E */
  ki = 0;
  while ( *s )
  {
    c0 = (unsigned __int8)*s;
    c1 = (unsigned __int8)s[1];
    if ( (c0 & 0x80u) == 0 || (c1 & 0x80u) == 0 )
    {
      if ( ki )
      {
        print_str(stream, "\x1B(B");
        ki = 0;
      }
      v4 = *s++;
      print_char(stream, v4);
    }
    else
    {
      if ( !ki )
      {
        print_str(stream, "\x1B$B");
        ki = 1;
      }
      v2 = c0;
      LOBYTE(v2) = c0 & 0x7F;
      print_char(stream, v2);
      v3 = c1;
      LOBYTE(v3) = c1 & 0x7F;
      print_char(stream, v3);
      s += 2;
    }
  }
  if ( ki )
    print_str(stream, "\x1B(B");
}

static void __cdecl print_sjis(void *stream, char *s)
{
  int v2; // eax
  int v3; // eax
  int v4; // [esp-4h] [ebp-Ch]
  int c1; // [esp+0h] [ebp-8h]
  int c1_1; // [esp+0h] [ebp-8h]
  int c0; // [esp+4h] [ebp-4h]

  while ( *s )
  {
    c0 = (unsigned __int8)*s;
    c1 = (unsigned __int8)s[1];
    if ( (c0 & 0x80u) == 0 || (c1 & 0x80u) == 0 )
    {
      v4 = *s++;
      print_char(stream, v4);
    }
    else
    {
      if ( (c0 & 1) != 0 )
      {
        if ( (unsigned __int8)s[1] > 0xDFu )
          v2 = c1 - 96;
        else
          v2 = c1 - 97;
      }
      else
      {
        v2 = c1 - 2;
      }
      c1_1 = v2;
      if ( (unsigned __int8)*s > 0xDFu )
        v3 = ((c0 - 223) >> 1) + 224;
      else
        v3 = ((c0 - 161) >> 1) + 129;
      print_char(stream, v3);
      print_char(stream, c1_1);
      s += 2;
    }
  }
}

static int __cdecl add_help_map(int ej, int level, char *key, char **pl)
{
  size_t v4; // eax
  HELP_MAP *tail; // edx
  HELP_MAP *hm; // [esp+4h] [ebp-4h]

  v4 = strlen(key);
  hm = (HELP_MAP *)ds_alloc(v4 + sizeof(HELP_MAP) + 1);
  if ( !hm )
    return -1;
  hm->ej = ej;
  hm->level = level;
  hm->key = (char *)&hm[1];
  strcpy(hm->key, key);
  hm->pl = pl;
  tail = help_maps.tail;
  hm->back = help_maps.tail;
  if ( tail )
    hm->back->forw = hm;
  else
    help_maps.head = hm;
  hm->forw = 0;
  help_maps.tail = hm;
  return 0;
}

static void __cdecl build_help_map(int lang)
{
  int level; // [esp+4h] [ebp-414h]
  char buf[1024]; // [esp+8h] [ebp-410h] BYREF
  char *q; // [esp+408h] [ebp-10h]
  char *p; // [esp+40Ch] [ebp-Ch]
  char *ps; // [esp+410h] [ebp-8h]
  char **pl; // [esp+414h] [ebp-4h]

  level = 0;
  if ( ++first_18 == 1 )
  {
    for ( pl = help_db; ; ++pl )
    {
      ps = *pl;
      if ( !ps )
        break;
      if ( valid_delim(lang, ps) )
      {
        p = ps + 3;
        if ( ps[3] )
        {
          while ( *p )
          {
            while ( *p == 32 )
              ++p;
            q = buf;
            while ( *p && *p != 32 )
              *q++ = *p++;
            *q = 0;
            if ( add_help_map(ps[2], level, buf, pl + 1) )
              return;
          }
        }
        else if ( add_help_map(ps[2], level, (char *)"", pl + 1) )
        {
          return;
        }
      }
      else if ( *ps == 45 && ps[1] == 76 )
      {
        level = ps[2] - 48;
      }
    }
    add_help_map(45, level, "keyword", 0);
  }
}

int __cdecl dbg_help(char *name)
{
  int v1; // eax
  HELP_MAP *hm; // [esp+0h] [ebp-24h]
  HELP_MAP *hm_1; // [esp+0h] [ebp-24h]
  void *stream; // [esp+4h] [ebp-20h]
  int n; // [esp+8h] [ebp-1Ch]
  int level; // [esp+Ch] [ebp-18h]
  int r; // [esp+10h] [ebp-14h]
  int lang; // [esp+14h] [ebp-10h]
  char *pager; // [esp+18h] [ebp-Ch]
  char *ps; // [esp+1Ch] [ebp-8h]
  char **pl; // [esp+20h] [ebp-4h]

  r = 0;
  level = 0;
  stream = 0;
  lang = get_help_lang();
  build_help_map(lang);
  pager = get_help_pager();
  if ( *pager )
    stream = ds_popen(pager, "w");
  current_col = 0;
  if ( !strcmp("keyword", name) )
  {
    for ( hm = help_maps.head; hm; hm = hm->forw )
    {
      if ( *hm->key && valid_lang(lang, hm) )
      {
        if ( current_col + strlen(hm->key) + 1 > 0x4F || hm->level != level )
        {
          print_nl(stream);
          level = hm->level;
          n = level;
          while ( 1 )
          {
            v1 = n--;
            if ( v1 <= 0 )
              break;
            print_str(stream, "  ");
          }
        }
        print_str(stream, " ");
        print_str(stream, hm->key);
      }
    }
    print_nl(stream);
    return 1;
  }
  else
  {
    for ( hm_1 = help_maps.head; hm_1; hm_1 = hm_1->forw )
    {
      if ( !strcmp(name, hm_1->key) && valid_lang(lang, hm_1) )
      {
        r = 1;
        for ( pl = hm_1->pl; ; ++pl )
        {
          ps = *pl;
          if ( !*pl || *ps == 45 )
            break;
          if ( lang == 2 )
          {
            print_jis(stream, ps);
          }
          else if ( lang > 2 && lang == 3 )
          {
            print_sjis(stream, ps);
          }
          else
          {
            print_str(stream, ps);
          }
          print_nl(stream);
        }
        break;
      }
    }
    if ( stream )
      ds_pclose(stream);
    if ( !r )
    {
      ds_printf("%s: keyword not found:", name);
      ds_printf(" `help keyword' gives all keywords.\n");
    }
    return 1;
  }
}

int __cdecl dbg_help_completion(DS_HISTBUF *hb, char *name)
{
  HELP_MAP *hm; // [esp+0h] [ebp-20h]
  HELP_MAP *hm_1; // [esp+0h] [ebp-20h]
  int lns; // [esp+4h] [ebp-1Ch]
  int i; // [esp+8h] [ebp-18h]
  int nm; // [esp+Ch] [ebp-14h]
  int n; // [esp+10h] [ebp-10h]
  int lang; // [esp+14h] [ebp-Ch]
  char *cn; // [esp+18h] [ebp-8h]
  char *p; // [esp+1Ch] [ebp-4h]
  char *p_1; // [esp+1Ch] [ebp-4h]
  char *p_2; // [esp+1Ch] [ebp-4h]
  char *p_3; // [esp+1Ch] [ebp-4h]

  lang = get_help_lang();
  build_help_map(lang);
  n = strlen(name);
  nm = 0;
  for ( hm = help_maps.head; hm; hm = hm->forw )
  {
    if ( valid_lang(lang, hm) )
    {
      p = hm->key;
      if ( *p )
      {
        if ( !n || !ds_strncmp(name, p, n) )
        {
          if ( ++nm == 1 )
          {
            cn = p;
            i = strlen(p);
          }
          else
          {
            lns = i;
            for ( i = 0; lns > i && p[i] == cn[i]; ++i )
              ;
          }
        }
      }
    }
  }
  if ( !nm )
    return 0;
  if ( nm == 1 )
  {
    for ( p_1 = &cn[n]; *p_1; ++p_1 )
      ds_editline(hb, *p_1, 0);
    return 1;
  }
  else
  {
    for ( p_2 = &cn[n]; *p_2 && p_2 < &cn[i]; ++p_2 )
      ds_editline(hb, *p_2, 0);
    ds_printf("\n");
    current_col = 0;
    for ( hm_1 = help_maps.head; hm_1; hm_1 = hm_1->forw )
    {
      if ( valid_lang(lang, hm_1) )
      {
        p_3 = hm_1->key;
        if ( *p_3 )
        {
          if ( !n || !ds_strncmp(name, p_3, n) )
          {
            if ( current_col + strlen(p_3) + 1 > 0x4F )
            {
              ds_printf("\n");
              current_col = 0;
            }
            current_col += ds_printf(" %s", hm_1->key);
          }
        }
      }
    }
    return -1;
  }
}

static int __cdecl valid_delim(int lang, char *p)
{
  if ( *p != 45 )
    return 0;

  return p[1] == 45 || p[1] == TARGET_DID;
}

static int __cdecl valid_lang(int lang, HELP_MAP *hm)
{
  if ( hm->ej != 45 )
  {
    if ( lang <= 0 || lang > 3 )
    {
      if ( hm->ej != 101 )
        return 0;
    }
    else if ( hm->ej != 106 )
    {
      return 0;
    }
  }
  return 1;
}

